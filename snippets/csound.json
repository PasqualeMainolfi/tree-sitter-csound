{
    "schedkwhen": {
        "prefix": "schedkwhen(ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur )",
        "body": "schedkwhen",
        "description": "Adds a new score event generated by a k-rate trigger."
    },
    "cross2": {
        "prefix": "cross2(ain1, ain2, isize, ioverlap, iwin, kbias)",
        "body": "cross2",
        "description": "Cross synthesis using FFT&#x27;s."
    },
    "vmultv_i": {
        "prefix": "vmultv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vmultv_i",
        "description": "Performs mutiplication between two vectorial control signals at init time."
    },
    "fmbell": {
        "prefix": "fmbell(kamp, kfreq, kc1, kc2, kvdepth, kvrat [, ifn1, ifn2, ifn3, ifn4, ivfn, isus])",
        "body": "fmbell",
        "description": "Uses FM synthesis to create a tublar bell sound."
    },
    "pvsvoc": {
        "prefix": "pvsvoc(famp, fexc, kdepth, kgain [, kcoefs])",
        "body": "pvsvoc",
        "description": "Combine the spectral envelope of one fsig with the excitation (frequencies) of another."
    },
    "MixerClear": {
        "prefix": "MixerClear()",
        "body": "MixerClear",
        "description": "Resets all channels of a buss to 0."
    },
    "ATSaddnz": {
        "prefix": "ATSaddnz(ktimepnt, iatsfile, ibands [, ibandoffset, ibandincr])",
        "body": "ATSaddnz",
        "description": "Uses the data from an ATS analysis file to perform noise resynthesis using a modified randi function."
    },
    "linen": {
        "prefix": "linen({x, k}amp, irise, idur, idec)",
        "body": "linen",
        "description": "Applies a straight line rise and decay pattern to an input amp signal."
    },
    "filenchnls": {
        "prefix": "filenchnls(ifilcod [, iallowraw])",
        "body": "filenchnls",
        "description": "Returns the number of channels in a sound file."
    },
    "pop_f": {
        "prefix": "pop_f()",
        "body": "pop_f",
        "description": "Pops an f-sig frame from the global stack.  Deprecated."
    },
    "outipat": {
        "prefix": "outipat(ichn, inotenum, ivalue, imin, imax)",
        "body": "outipat",
        "description": "Sends polyphonic MIDI aftertouch messages at i-rate."
    },
    "vsubv_i": {
        "prefix": "vsubv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vsubv_i",
        "description": "Performs subtraction between two vectorial control signals at init time."
    },
    "ftsavek": {
        "prefix": "ftsavek(\"filename\", ktrig, iflag, ifn1 [, ifn2] [...])",
        "body": "ftsavek",
        "description": "Save a set of previously-allocated tables to a file."
    },
    "dbfsamp": {
        "prefix": "dbfsamp(x)",
        "body": "dbfsamp",
        "description": "Returns the decibel equivalent of the raw amplitude _x_, relative to full scale amplitude."
    },
    "outkc14": {
        "prefix": "outkc14(kchn, kmsb, klsb, kvalue, kmin, kmax)",
        "body": "outkc14",
        "description": "Sends 14-bit MIDI controller output at k-rate."
    },
    "linenr": {
        "prefix": "linenr({x, k}amp, irise, idec, iatdec)",
        "body": "linenr",
        "description": "The _linen_ opcode extended with a final release segment."
    },
    "vbapzmove": {
        "prefix": "vbapzmove(inumchnls, istartndx, asig, idur, ispread, ifldnum, ifld1, ifld2, [...])",
        "body": "vbapzmove",
        "description": "Writes a multi-channel audio signal to a ZAK array with moving virtual sources."
    },
    "median": {
        "prefix": "median(asig, ksize, imaxsize [, iskip])",
        "body": "median",
        "description": "A median filter, a variant FIR lowpass filter."
    },
    "setctrl": {
        "prefix": "setctrl(inum, ival, itype)",
        "body": "setctrl",
        "description": "Configurable slider controls for realtime user input."
    },
    "fmwurlie": {
        "prefix": "fmwurlie(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn)",
        "body": "fmwurlie",
        "description": "Uses FM synthesis to create a Wurlitzer electric piano sound."
    },
    "eventtype": {
        "prefix": "eventtype()",
        "body": "eventtype",
        "description": "Returns the event type for an instrument."
    },
    "lpcfilter": {
        "prefix": "lpcfilter(asig, asrc, kflg, kprd, isiz, iord [, iwin])",
        "body": "lpcfilter",
        "description": "Streaming linear prediction all-pole filter whose coefficients are obtained from streaming linear prediction analysis."
    },
    "tablew": {
        "prefix": "tablew({a, i, k}sig, andx, ifn [, ixmode] [, ixoff] [, iwgmode])",
        "body": "tablew",
        "description": "Change the contents of existing function tables."
    },
    "MixerSetLevel_i": {
        "prefix": "MixerSetLevel_i(isend, ibuss, igain)",
        "body": "MixerSetLevel_i",
        "description": "Sets the level at which signals from the send are added to the buss."
    },
    "midifilevents": {
        "prefix": "midifilevents([id:i])",
        "body": "midifilevents",
        "description": "Returns the number of events in a MIDI file."
    },
    "cmp": {
        "prefix": "cmp({a, k}1, S_operator, a2)",
        "body": "cmp",
        "description": "Compares audio signals or arrays."
    },
    "arduinoStop": {
        "prefix": "arduinoStop(iPort)",
        "body": "arduinoStop",
        "description": "Close a serial port using Arduino protocol."
    },
    "vincr": {
        "prefix": "vincr(accum, aincr)",
        "body": "vincr",
        "description": "Increments one audio variable with another signal, i.e. it accumulates output."
    },
    "specaddm": {
        "prefix": "specaddm(wsig1, wsig2 [, imul2])",
        "body": "specaddm",
        "description": "Perform a weighted add of two input spectra."
    },
    "noise": {
        "prefix": "noise(xamp, kbeta)",
        "body": "noise",
        "description": "A white noise generator with an IIR lowpass filter."
    },
    "tablera": {
        "prefix": "tablera(kfn, kstart, koff)",
        "body": "tablera",
        "description": "Reads tables in sequential locations to an a-rate variable."
    },
    "vibes": {
        "prefix": "vibes(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec)",
        "body": "vibes",
        "description": "Physical model related to the striking of a metal block as found in a vibraphone."
    },
    "mdelay": {
        "prefix": "mdelay(kstatus, kchan, kd1, kd2, kdelay)",
        "body": "mdelay",
        "description": "A MIDI delay opcode."
    },
    "getcfg": {
        "prefix": "getcfg(iopt)",
        "body": "getcfg",
        "description": "Return various configuration settings in Svalue as a string at init time."
    },
    "lposcil3": {
        "prefix": "lposcil3(kamp, kfreqratio, kloop, kend, ifn [, iphs])",
        "body": "lposcil3",
        "description": "Read sampled sound (mono or stereo) from a table, with looping, and high precision."
    },
    "clockon": {
        "prefix": "clockon(inum)",
        "body": "clockon",
        "description": "Starts one of a number of internal clocks."
    },
    "ftprint": {
        "prefix": "ftprint(ifn [, ktrig, kstart, kend, kstep, inumcols ])",
        "body": "ftprint",
        "description": "Print the contents of a table (for debugging)."
    },
    "cpstuni": {
        "prefix": "cpstuni(index, ifn)",
        "body": "cpstuni",
        "description": "Returns micro-tuning values at init-rate."
    },
    "gainslider": {
        "prefix": "gainslider(kindex)",
        "body": "gainslider",
        "description": "An implementation of a logarithmic gain curve which is similar to the gainslider~ object from Cycling 74 Max / MSP."
    },
    "scans": {
        "prefix": "scans(kamp, kfreq, ifn, id [, iorder])",
        "body": "scans",
        "description": "Generate audio output using scanned synthesis."
    },
    "powershape": {
        "prefix": "powershape(ain, kShapeAmount [, ifullscale])",
        "body": "powershape",
        "description": "Waveshapes a signal by raising it to a variable exponent."
    },
    "fprintks": {
        "prefix": "fprintks(\"filename\", \"string\" [, kval1] [, kval2] [...])",
        "body": "fprintks",
        "description": "Similar to [printks] but prints to a file."
    },
    "slider64": {
        "prefix": "slider64(ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., ictlnum64, imin64, imax64, init64, ifn64)",
        "body": "slider64",
        "description": "Creates a bank of 64 different MIDI control message numbers."
    },
    "bformdec2": {
        "prefix": "bformdec2(isetup, abform[], [idecoder, idistance, ifreq, imix, ifilel, ifiler])",
        "body": "bformdec2",
        "description": "Decodes an Ambisonics B format signal into loudspeaker specific signals, with dual--band decoding and near--field compensation."
    },
    "loopseg": {
        "prefix": "loopseg(kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] [, kvalue2] [, ktime2][...])",
        "body": "loopseg",
        "description": "Generate control signal consisting of linear segments delimited by two or more specified points."
    },
    "upsamp": {
        "prefix": "upsamp(ksig)",
        "body": "upsamp",
        "description": "Modify a signal by up-sampling."
    },
    "modmatrix": {
        "prefix": "modmatrix(iresfn, isrcmodfn, isrcparmfn, imodscale, inum_mod, inum_parm, kupdate)",
        "body": "modmatrix",
        "description": "Modulation matrix opcode with optimizations for sparse matrices."
    },
    "ampmidicurve": {
        "prefix": "ampmidicurve({i, k}velocity, idynamicrange, iexponent)",
        "body": "ampmidicurve",
        "description": "Maps an input MIDI velocity number to an output gain factor with a maximum value of 1, modifying the output gain by a dynamic range and a shaping exponent."
    },
    "nestedap": {
        "prefix": "nestedap(asig, imode, imaxdel, idel1, igain1 [, idel2] [, igain2] [, idel3] [, igain3] [, istor])",
        "body": "nestedap",
        "description": "Three different nested all-pass filters, useful for implementing reverbs."
    },
    "dbamp": {
        "prefix": "dbamp(x)",
        "body": "dbamp",
        "description": "Returns the decibel equivalent of the raw amplitude _x_."
    },
    "sfload": {
        "prefix": "sfload(\"filename\")",
        "body": "sfload",
        "description": "Loads an entire SoundFont2 (SF2) sample file into memory."
    },
    "tonek": {
        "prefix": "tonek(ksig, khp [, iskip])",
        "body": "tonek",
        "description": "A first-order recursive low-pass filter with variable frequency response."
    },
    "vexpseg": {
        "prefix": "vexpseg(ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]])",
        "body": "vexpseg",
        "description": "Vectorial envelope generator. Generate exponential vectorial segments."
    },
    "pvoc": {
        "prefix": "pvoc(ktimpnt, kfmod, ifilcod [, ispecwp] [, iextractmode] [, ifreqlim] [, igatefn])",
        "body": "pvoc",
        "description": "Implements signal reconstruction using an fft-based phase vocoder."
    },
    "vtabwa": {
        "prefix": "vtabwa(andx, ifn, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ])",
        "body": "vtabwa",
        "description": "Write vectors (to tables -or arrays of vectors) at a-rate."
    },
    "vtablewk": {
        "prefix": "vtablewk(kndx, kfn, ixmode, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ])",
        "body": "vtablewk",
        "description": "Write vectors (to tables -or arrays of vectors) at k-rate."
    },
    "platerev": {
        "prefix": "platerev(itabexcite. itabouts, kbndry, iaspect, istiff, idecay, iloss, aexcite [, aexcite2, ...])",
        "body": "platerev",
        "description": "Models the reverberation of a rectangular metal plate with settable physical characteristics when excited by audio signal(s)."
    },
    "vtablek": {
        "prefix": "vtablek(kndx, kfn, kinterp, ixmode, kout1 [, kout2, kout3, .... , koutN ])",
        "body": "vtablek",
        "description": "Read vectors (from tables -or arrays of vectors) at k-rate."
    },
    "printarray": {
        "prefix": "printarray({i, k}xs[] [, Smft, Slabel ])",
        "body": "printarray",
        "description": "Print the contents of an array."
    },
    "compress": {
        "prefix": "compress(aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook)",
        "body": "compress",
        "description": "Compress, limit, expand, duck or gate an audio signal."
    },
    "midifilelen": {
        "prefix": "midifilelen([id:i])",
        "body": "midifilelen",
        "description": "Returns the length of a MIDI file."
    },
    "stack": {
        "prefix": "stack(iStackSize)",
        "body": "stack",
        "description": "Initializes and sets the size of the global stack. Deprecated."
    },
    "ftfree": {
        "prefix": "ftfree(ifno, iwhen)",
        "body": "ftfree",
        "description": "Deletes function table."
    },
    "dispfft": {
        "prefix": "dispfft(xsig, iprd, iwsiz [, iwtyp] [, idbout] [, iwtflg] [,imin] [,imax])",
        "body": "dispfft",
        "description": "Displays the Fourier Transform of an audio or control signal."
    },
    "spdist": {
        "prefix": "spdist(ifn, ktime, kx, ky)",
        "body": "spdist",
        "description": "Calculates distance values from xy coordinates."
    },
    "pchtom": {
        "prefix": "pchtom({i, k}pch)",
        "body": "pchtom",
        "description": "Convert pch to midi note number."
    },
    "framebuffer": {
        "prefix": "framebuffer({a, k}in, isize)",
        "body": "framebuffer",
        "description": "Read audio signals into 1 dimensional k-rate arrays and vice-versa with a specified buffer size."
    },
    "vexp": {
        "prefix": "vexp(ifn, kval, kelements [, kdstoffset] [, kverbose])",
        "body": "vexp",
        "description": "Performs power-of operations between a vector and a scalar."
    },
    "outvalue": {
        "prefix": "outvalue(\"channel name\", ivalue)",
        "body": "outvalue",
        "description": "Sends an i-rate or k-rate signal or string to a user-defined channel."
    },
    "strtod": {
        "prefix": "strtod({i, S}str)",
        "body": "strtod",
        "description": "Converts a string to a floating point value (i-rate)."
    },
    "=": {
        "prefix": "ares = xarg",
        "body": "=",
        "description": "Performs a simple assignment."
    },
    "outz": {
        "prefix": "outz(ksig1)",
        "body": "outz",
        "description": "Writes multi-channel audio data from a ZAK array to an external device or stream."
    },
    "exciter": {
        "prefix": "exciter(asig, kfreq, kceil, kharmonics, kblend)",
        "body": "exciter",
        "description": "A non-linear filter system to excite the signal."
    },
    "-": {
        "prefix": "-a  (no rate restriction)",
        "body": "-",
        "description": "Subtraction operator."
    },
    "filter2": {
        "prefix": "filter2({a, k}sig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN)",
        "body": "filter2",
        "description": "General purpose custom filter."
    },
    "rnd": {
        "prefix": "rnd(x)",
        "body": "rnd",
        "description": "Returns a random number in a unipolar range at the rate given by the input argument."
    },
    "pvsbandp": {
        "prefix": "pvsbandp(fsigin, xlowcut, xlowfull, xhighfull, xhighcut [, ktype])",
        "body": "pvsbandp",
        "description": "A band pass filter working in the spectral domain."
    },
    "serialWrite": {
        "prefix": "serialWrite(iPort, iByte)",
        "body": "serialWrite",
        "description": "Write data to a serial port for arduino."
    },
    "madsr": {
        "prefix": "madsr(iatt, idec, islev, irel [, idel] [, ireltim])",
        "body": "madsr",
        "description": "Calculates the classical ADSR envelope using the [linsegr] mechanism."
    },
    "delay": {
        "prefix": "delay(asig, idlt [, iskip])",
        "body": "delay",
        "description": "Delays an input signal by some time interval."
    },
    "pan2": {
        "prefix": "pan2(asig, xp [, imode])",
        "body": "pan2",
        "description": "Distribute an audio signal across two channels with a choice of methods."
    },
    "butterbr": {
        "prefix": "butterbr(asig, xfreq, xband [, iskip])",
        "body": "butterbr",
        "description": "A band-reject Butterworth filter."
    },
    "count_i": {
        "prefix": "count_i(icnt)",
        "body": "count_i",
        "description": "Get the next value from a counter."
    },
    "print": {
        "prefix": "print(iarg [, iarg1] [, iarg2] [...])",
        "body": "print",
        "description": "Displays the values of init (i-rate) variables."
    },
    "dcblock2": {
        "prefix": "dcblock2(ain [, iorder] [, iskip])",
        "body": "dcblock2",
        "description": "Implements a DC blocking filter with improved DC attenuation."
    },
    "kgoto": {
        "prefix": "kgoto(label)",
        "body": "kgoto",
        "description": "During the p-time passes only, unconditionally transfer control to the statement labeled by _label_."
    },
    "gendyx": {
        "prefix": "gendyx(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum])",
        "body": "gendyx",
        "description": "Variation of the dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis."
    },
    "butterhp": {
        "prefix": "butterhp(asig, kfreq [, iskip])",
        "body": "butterhp",
        "description": "A high-pass Butterworth filter."
    },
    "hrtfmove2": {
        "prefix": "hrtfmove2(asrc, kAz, kElev, ifilel, ifiler [,ioverlap, iradius, isr])",
        "body": "hrtfmove2",
        "description": "Generates dynamic 3d binaural audio for headphones using a Woodworth based spherical head model with improved low frequency phase accuracy."
    },
    "sprintf": {
        "prefix": "sprintf(Sfmt, xarg [, xarg [, ... ]])",
        "body": "sprintf",
        "description": "printf-style formatted output to a string variable."
    },
    "sfplist": {
        "prefix": "sfplist(ifilhandle)",
        "body": "sfplist",
        "description": "Prints a list of all presets of a previously loaded SoundFont2 (SF2) sample file."
    },
    "filepeak": {
        "prefix": "filepeak(ifilcod [, ichnl])",
        "body": "filepeak",
        "description": "Returns the peak absolute value of a sound file."
    },
    "dripwater": {
        "prefix": "dripwater(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1] [, ifreq2])",
        "body": "dripwater",
        "description": "Semi-physical model of a water drop."
    },
    "inz": {
        "prefix": "inz(ksig1)",
        "body": "inz",
        "description": "Reads multi-channel audio samples into a ZAK array from an external device or stream."
    },
    "ctrlprintpresets": {
        "prefix": "ctrlprintpresets([Sfilenam])",
        "body": "ctrlprintpresets",
        "description": "Prints the current collection of presets for MIDI controllers in a format that can be used in an orchestra, to the console or a file."
    },
    "sorta": {
        "prefix": "sorta(k/i[])",
        "body": "sorta",
        "description": "Takes a numeric array (k or i-rate) and returns it sorted in ascending order."
    },
    "duserrnd": {
        "prefix": "duserrnd({i, k}tableNum)",
        "body": "duserrnd",
        "description": "Discrete USER-defined-distribution RaNDom generator."
    },
    "fftinv": {
        "prefix": "fftinv(kin[])",
        "body": "fftinv",
        "description": "Complex-to-complex Inverse Fast Fourier Transform."
    },
    "product": {
        "prefix": "product(karr[]/iarr[])",
        "body": "product",
        "description": "Multiplies any number of a-rate signals."
    },
    "rfft": {
        "prefix": "rfft(in:k[])",
        "body": "rfft",
        "description": "Fast Fourier Transform of a real-value array."
    },
    "tableseg": {
        "prefix": "tableseg(ifn1, idur1, ifn2 [, idur2] [, ifn3] [...])",
        "body": "tableseg",
        "description": "Creates a new function table by making linear segments between values in stored function tables."
    },
    "pinker": {
        "prefix": "pinker()",
        "body": "pinker",
        "description": "Generates pink noise (-3dB/oct response) by the _NewShade of Pink_ algorithm of Stefan Stenzel."
    },
    "pvsinit": {
        "prefix": "pvsinit(isize [, iolap, iwinsize, iwintype, iformat])",
        "body": "pvsinit",
        "description": "Initialise a spectral (f) variable to zero."
    },
    "midipitchbend": {
        "prefix": "midipitchbend(xpitchbend [, ilow] [, ihigh])",
        "body": "midipitchbend",
        "description": "Gets a MIDI pitchbend value."
    },
    "hrtfer": {
        "prefix": "hrtfer(asig, kaz, kelev, \"HRTFcompact\")",
        "body": "hrtfer",
        "description": "Creates 3D audio for two speakers. Output is binaural (headphone) 3D audio."
    },
    "pset": {
        "prefix": "pset(icon1 [, icon2] [...])",
        "body": "pset",
        "description": "Defines and initializes numeric arrays at orchestra load time."
    },
    "diff": {
        "prefix": "diff({a, k}sig [, iskip])",
        "body": "diff",
        "description": "Modify a signal by differentiation."
    },
    "tabmorph": {
        "prefix": "tabmorph(kindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 [, ifn3, ifn4, ...,ifnN])",
        "body": "tabmorph",
        "description": "Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables."
    },
    "resonr": {
        "prefix": "resonr(asig, xcf, xbw [, iscl] [, iskip])",
        "body": "resonr",
        "description": "A second-order, two-pole two-zero bandpass filter with variable frequency response."
    },
    "wguide1": {
        "prefix": "wguide1(asig, xfreq, kcutoff, kfeedback)",
        "body": "wguide1",
        "description": "A simple waveguide model consisting of one delay-line and one first-order lowpass filter."
    },
    "strupperk": {
        "prefix": "strupperk(Ssrc)",
        "body": "strupperk",
        "description": "Convert Ssrc to upper case, and write the result to Sdst."
    },
    "vibrato": {
        "prefix": "vibrato(kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq, kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs])",
        "body": "vibrato",
        "description": "Generates a natural-sounding user-controllable vibrato."
    },
    "rifft": {
        "prefix": "rifft({in:Complex[], in:k[]})",
        "body": "rifft",
        "description": "Complex-to-real Inverse Fast Fourier Transform."
    },
    "pchoct": {
        "prefix": "pchoct(oct)",
        "body": "pchoct",
        "description": "Converts an octave-point-decimal value to pitch-class."
    },
    "c2r": {
        "prefix": "c2r(kin[])",
        "body": "c2r",
        "description": "Real to complex format conversion."
    },
    "MixerReceive": {
        "prefix": "MixerReceive(ibuss, ichannel)",
        "body": "MixerReceive",
        "description": "Receives an arate signal that has been mixed onto a channel of a buss."
    },
    "eqfil": {
        "prefix": "eqfil(ain, kcf, kbw, kgai [, istor])",
        "body": "eqfil",
        "description": "Equalizer filter."
    },
    "pvsanal": {
        "prefix": "pvsanal(ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit])",
        "body": "pvsanal",
        "description": "Generate an fsig from a mono audio source ain, using phase vocoder overlap-add analysis."
    },
    "ftgentmp": {
        "prefix": "ftgentmp(ip1, ip2dummy, isize, igen, iarga, iargb, ...)",
        "body": "ftgentmp",
        "description": "Generate a score function table from within the orchestra, which is deleted at the end of the note."
    },
    "pvread": {
        "prefix": "pvread(ktimpnt, ifile, ibin)",
        "body": "pvread",
        "description": "Reads from a [pvoc] file and returns the frequency and amplitude from a single analysis channel or bin."
    },
    "birnd": {
        "prefix": "birnd(x)",
        "body": "birnd",
        "description": "Returns a random number in a bi-polar range."
    },
    "tbvcf": {
        "prefix": "tbvcf(asig, xfco, xres, kdist, kasym [, iskip])",
        "body": "tbvcf",
        "description": "Models some of the filter characteristics of a Roland TB303 voltage-controlled filter."
    },
    "ATSadd": {
        "prefix": "ATSadd(ktimepnt, kfmod, iatsfile, ifn, ipartials [, ipartialoffset, ipartialincr, igatefn])",
        "body": "ATSadd",
        "description": "Uses the data from an ATS analysis file to perform additive synthesis using an internal array of interpolating oscillators."
    },
    "lposcilsa": {
        "prefix": "lposcilsa(aamp, kfreqratio, kloop, kend, ift [,iphs])",
        "body": "lposcilsa",
        "description": "Read stereo sampled sound from a table with looping and high precision."
    },
    "grain2": {
        "prefix": "grain2(kcps, kfmd, kgdur, iovrlp, kfn, iwfn [, irpow] [, iseed] [, imode])",
        "body": "grain2",
        "description": "Easy-to-use granular synthesis texture generator."
    },
    "vco": {
        "prefix": "vco(xamp, xcps, iwave, kpw [, ifn] [, imaxd] [, ileak] [, inyx] [, iphs] [, iskip])",
        "body": "vco",
        "description": "Implementation of a band limited, analog modeled oscillator."
    },
    "filelen": {
        "prefix": "filelen(ifilcod, [iallowraw])",
        "body": "filelen",
        "description": "Returns the length of a sound file."
    },
    "notnum": {
        "prefix": "notnum()",
        "body": "notnum",
        "description": "Get a note number from a MIDI event."
    },
    "ftsr": {
        "prefix": "ftsr(x)",
        "body": "ftsr",
        "description": "Returns the sampling-rate of a stored function table."
    },
    "vwrap": {
        "prefix": "vwrap(ifn, kmin, kmax, ielements)",
        "body": "vwrap",
        "description": "Wraps elements of vectorial control signals."
    },
    "cabasa": {
        "prefix": "cabasa(iamp, idettack [, inum] [, idamp] [, imaxshake])",
        "body": "cabasa",
        "description": "Semi-physical model of a cabasa sound."
    },
    "lastcycle": {
        "prefix": "lastcycle()",
        "body": "lastcycle",
        "description": "Indicates whether an event is in its last performance cycle."
    },
    "outipc": {
        "prefix": "outipc(ichn, iprog, imin, imax)",
        "body": "outipc",
        "description": "Sends MIDI program change messages at i-rate."
    },
    "midglobal": {
        "prefix": "midglobal(isource, instrnum [, instrnum...])",
        "body": "midglobal",
        "description": "An opcode which can be used to implement a remote midi orchestra. This opcode will broadcast the midi events to all the machines involved in the remote concert."
    },
    "tableng": {
        "prefix": "tableng({i, k}fn)",
        "body": "tableng",
        "description": "Interrogates a function table for length."
    },
    "serialBegin": {
        "prefix": "serialBegin(SPortName [, ibaudRate])",
        "body": "serialBegin",
        "description": "Open a serial port for arduino."
    },
    "scantable": {
        "prefix": "scantable(kamp, kpch, ipos, imass, istiff, idamp, ivel)",
        "body": "scantable",
        "description": "A simpler scanned synthesis implementation."
    },
    "temposcal": {
        "prefix": "temposcal(ktimescal, kamp, kpitch, ktab, klock [,ifftsize, idecim, ithresh])",
        "body": "temposcal",
        "description": "Phase-locked vocoder processing with onset detection/processing, &#x27;tempo-scaling&#x27;."
    },
    "invalue": {
        "prefix": "invalue(\"channel name\")",
        "body": "invalue",
        "description": "Reads a k-rate or i-rate signal or string from a user-defined channel."
    },
    "zaw": {
        "prefix": "zaw(asig, kndx)",
        "body": "zaw",
        "description": "Writes to a za variable at a-rate without mixing."
    },
    "ihold": {
        "prefix": "ihold()",
        "body": "ihold",
        "description": "Causes a finite-duration note to become a &amp;#8220;held&amp;#8221; note."
    },
    "ftchnls": {
        "prefix": "ftchnls(x)",
        "body": "ftchnls",
        "description": "Returns the number of channels in a stored function table."
    },
    "lowresx": {
        "prefix": "lowresx(asig, xcutoff, xresonance [, inumlayer] [, iskip])",
        "body": "lowresx",
        "description": "Simulates layers of serially connected resonant lowpass filters."
    },
    "ATSpartialtap": {
        "prefix": "ATSpartialtap(ipartialnum)",
        "body": "ATSpartialtap",
        "description": "Returns a frequency, amplitude pair from an [ATSbufread] opcode."
    },
    "tablewkt": {
        "prefix": "tablewkt({a, k}sig, andx, kfn [, ixmode] [, ixoff] [, iwgmode])",
        "body": "tablewkt",
        "description": "Change the contents of existing function tables."
    },
    "else": {
        "prefix": "else",
        "body": "else",
        "description": "Executes a block of code when an &quot;if...then&quot; condition is false."
    },
    "adsynt": {
        "prefix": "adsynt(kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs])",
        "body": "adsynt",
        "description": "Performs additive synthesis with an arbitrary number of partials, not necessarily harmonic."
    },
    "expseg": {
        "prefix": "expseg(ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "expseg",
        "description": "Trace a series of exponential segments between specified points."
    },
    "areson": {
        "prefix": "areson(asig, kcf, kbw [, iscl] [, iskip])",
        "body": "areson",
        "description": "A notch filter whose transfer functions are the complements of the reson opcode."
    },
    "outkpat": {
        "prefix": "outkpat(kchn, knotenum, kvalue, kmin, kmax)",
        "body": "outkpat",
        "description": "Sends polyphonic MIDI aftertouch messages at k-rate."
    },
    "binit": {
        "prefix": "binit(fin, isize)",
        "body": "binit",
        "description": "PVS tracks to amplitude+frequency conversion."
    },
    "pgmassign": {
        "prefix": "pgmassign(ipgm, ins [, ichn])",
        "body": "pgmassign",
        "description": "Assigns an instrument number to a specified MIDI program."
    },
    "initc21": {
        "prefix": "initc21(ichan, ictlno1, ictlno2, ictlno3, ivalue)",
        "body": "initc21",
        "description": "Initializes the controllers used to create a 21-bit MIDI value."
    },
    "tablefilteri": {
        "prefix": "tablefilteri(iouttable, iintatble, imode, iparam)",
        "body": "tablefilteri",
        "description": "Filters a source table and writes result into a destination table."
    },
    "<=": {
        "prefix": "(a <= b ? v1 : v2)",
        "body": "<=",
        "description": "Determines if one value is less than or equal to another."
    },
    "lpfreson": {
        "prefix": "lpfreson(asig, kfrqratio)",
        "body": "lpfreson",
        "description": "Resynthesises a signal from the data passed internally by a previous _lpread_, applying formant shifting."
    },
    "lagud": {
        "prefix": "lagud({a, k}in, klagup, klagdown [, initialvalue])",
        "body": "lagud",
        "description": "Exponential Lag."
    },
    "#include": {
        "prefix": "#include \"filename\"",
        "body": "#include",
        "description": "Includes an external file for processing."
    },
    "strstrip": {
        "prefix": "strstrip(Sin [, Smode])",
        "body": "strstrip",
        "description": "Strip whitespace from string."
    },
    "expsegr": {
        "prefix": "expsegr(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)",
        "body": "expsegr",
        "description": "Trace a series of exponential segments between specified points including a release segment."
    },
    "pvstanal": {
        "prefix": "pvstanal(ktimescal, kamp, kpitch, ktab, [kdetect, kwrap, ioffset, ifftsize, ihop, idbthresh])",
        "body": "pvstanal",
        "description": "Phase vocoder analysis processing with onset detection/processing."
    },
    "strget": {
        "prefix": "strget(indx)",
        "body": "strget",
        "description": "Set  a string variable at initialization time to the value stored in [strset] table at the specified index, or a string p-field from the score."
    },
    "pvsinfo": {
        "prefix": "pvsinfo(fsrc)",
        "body": "pvsinfo",
        "description": "Get information from a PVOC-EX formatted source."
    },
    "pvsmix": {
        "prefix": "pvsmix(fsigin1, fsigin2)",
        "body": "pvsmix",
        "description": "Mix &#x27;seamlessly&#x27; two pv signals."
    },
    "outic14": {
        "prefix": "outic14(ichn, imsb, ilsb, ivalue, imin, imax)",
        "body": "outic14",
        "description": "Sends 14-bit MIDI controller output at i-rate."
    },
    "vco2init": {
        "prefix": "vco2init(iwave [, ibasfn] [, ipmul] [, iminsiz] [, imaxsiz] [, isrcft])",
        "body": "vco2init",
        "description": "Calculates tables for use by vco2 opcode."
    },
    "setscorepos": {
        "prefix": "setscorepos(ipos)",
        "body": "setscorepos",
        "description": "Sets the playback position of the current score performance to a given position."
    },
    "babo": {
        "prefix": "babo(asig, ksrcx, ksrcy, ksrcz, irx, iry, irz [, idiff] [, ifno])",
        "body": "babo",
        "description": "A physical model reverberator."
    },
    "zfilter2": {
        "prefix": "zfilter2(asig, kdamp, kfreq, iM, iN, ib0, ib1, ..., ibM, ia1,ia2, ..., iaN)",
        "body": "zfilter2",
        "description": "Performs filtering using a transposed form-II digital filter lattice with radial pole-shearing and angular pole-warping."
    },
    "linsegr": {
        "prefix": "linsegr(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)",
        "body": "linsegr",
        "description": "Trace a series of line segments between specified points including a release segment."
    },
    "socksend": {
        "prefix": "socksend({a, k}sig, Sipaddr, iport, ilength)",
        "body": "socksend",
        "description": "Sends data to other processes using the low-level UDP or TCP protocols."
    },
    "multitap": {
        "prefix": "multitap(asig [, itime1, igain1] [, itime2, igain2] [...])",
        "body": "multitap",
        "description": "Multitap delay line implementation."
    },
    "mrtmsg": {
        "prefix": "mrtmsg(imsgtype)",
        "body": "mrtmsg",
        "description": "Send system real-time messages to the MIDI OUT port."
    },
    "transeg": {
        "prefix": "transeg(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)",
        "body": "transeg",
        "description": "Constructs a user-definable envelope."
    },
    "vtabi": {
        "prefix": "vtabi(indx, ifn, iout1 [, iout2, iout3, .... , ioutN ])",
        "body": "vtabi",
        "description": "Read vectors (from tables -or arrays of vectors) at init time."
    },
    "pvslpc": {
        "prefix": "pvslpc(asrc, idftsiz, ihop, iord [, iwin])",
        "body": "pvslpc",
        "description": "Streaming linear prediction analysis."
    },
    "nchnls_i": {
        "prefix": "nchnls_i = iarg",
        "body": "nchnls_i",
        "description": "Sets the number of channels of audio input."
    },
    "tabmorpha": {
        "prefix": "tabmorpha(aindex, aweightpoint, atabnum1, atabnum2, ifn1, ifn2 [, ifn3, ifn4, ... ifnN])",
        "body": "tabmorpha",
        "description": "Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables."
    },
    "moog": {
        "prefix": "moog(kamp, kfreq, kfiltq, kfiltrate, kvibf, kvamp, iafn, iwfn, ivfn)",
        "body": "moog",
        "description": "An emulation of a mini-Moog synthesizer."
    },
    "divz": {
        "prefix": "ares divz xa, xb, ksubst",
        "body": "divz",
        "description": "Safely divides two numbers."
    },
    "scansmap": {
        "prefix": "scansmap(kpos, kvel, iscan, kamp, kvamp [, iwhich])",
        "body": "scansmap",
        "description": "Allows the position and velocity of a node in a scanned process to be written."
    },
    "delay1": {
        "prefix": "delay1(asig [, iskip])",
        "body": "delay1",
        "description": "Delays an input signal by one sample."
    },
    "max_k": {
        "prefix": "max_k(asig, ktrig, itype)",
        "body": "max_k",
        "description": "Local maximum (or minimum) value of an incoming asig signal, checked in the time interval between ktrig has become true twice."
    },
    "ntrpol": {
        "prefix": "ntrpol({a, i, k}sig1, asig2, kpoint [, imin] [, imax])",
        "body": "ntrpol",
        "description": "Calculates the weighted mean value (i.e. linear interpolation) of two input signals."
    },
    "spf": {
        "prefix": "spf(alp,ahp,abp, xcf, x [, istor])",
        "body": "spf",
        "description": "Steiner-Parker filter."
    },
    "lposcil": {
        "prefix": "lposcil(kamp, kfreqratio, kloop, kend, ifn [, iphs])",
        "body": "lposcil",
        "description": "Read sampled sound (mono or stereo) from a table, with looping, and high precision."
    },
    "log10": {
        "prefix": "log10(x)",
        "body": "log10",
        "description": "Returns the base 10 log of _x_ (_x_ positive only)."
    },
    "allpole": {
        "prefix": "allpole(asig, kCoef[])",
        "body": "allpole",
        "description": "Allpole filter implementation using direct convolution."
    },
    "limit1": {
        "prefix": "limit1({i, k}arg)",
        "body": "limit1",
        "description": "Limits the value of an argument to the range [0,1]."
    },
    "S": {
        "prefix": "S(x)",
        "body": "S",
        "description": "Returns a string containg the numeric value of its argument."
    },
    "mp3in": {
        "prefix": "mp3in(ifilco [, iskptim, iformat, iskipinit, ibufsize])",
        "body": "mp3in",
        "description": "Reads mono or stereo audio data from an external MP3 file."
    },
    "strcpyk": {
        "prefix": "strcpyk(Ssrc)",
        "body": "strcpyk",
        "description": "Assign to a string variable by copying the source which may be a constant or another string variable."
    },
    "sr": {
        "prefix": "sr = iarg",
        "body": "sr",
        "description": "Sets the audio sampling rate."
    },
    "qnan": {
        "prefix": "qnan(x)",
        "body": "qnan",
        "description": "Returns the number of times the argument is not a number."
    },
    "cpspch": {
        "prefix": "cpspch(pch)",
        "body": "cpspch",
        "description": "Converts a pitch-class value to cycles-per-second."
    },
    "vdelayxq": {
        "prefix": "vdelayxq(ain1, ain2, ain3, ain4, adl, imd, iws [, ist])",
        "body": "vdelayxq",
        "description": "A 4-channel variable delay opcode with high quality interpolation."
    },
    "ftset": {
        "prefix": "ftset(tablenum, kvalue [, kstart=0, kend=0, kstep=1 ])",
        "body": "ftset",
        "description": "Sets multiple elements of a table to a given value."
    },
    "vtable1k": {
        "prefix": "vtable1k(kfn, kout1 [, kout2, kout3, .... , koutN ])",
        "body": "vtable1k",
        "description": "Read a vector (several scalars simultaneously) from a table at k-rate."
    },
    "xin": {
        "prefix": "xinarg1 [, xinarg2] ... [xinargN] xin",
        "body": "xin",
        "description": "Passes variables to a user-defined opcode block."
    },
    "ctrlprint": {
        "prefix": "ctrlprint(kcont[ [, Sfile])",
        "body": "ctrlprint",
        "description": "Print the saved values of MIDI controllers from an array to the console or a file."
    },
    "voice": {
        "prefix": "voice(kamp, kfreq, kphoneme, kform, kvibf, kvamp, ifn, ivfn)",
        "body": "voice",
        "description": "An emulation of a human voice."
    },
    "oscili": {
        "prefix": "oscili({x, k}amp, xcp [, ifn, iphs])",
        "body": "oscili",
        "description": "A simple oscillator with linear interpolation."
    },
    "vpowv": {
        "prefix": "vpowv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vpowv",
        "description": "Performs power-of operations between two vectorial control signals."
    },
    "bexprnd": {
        "prefix": "bexprnd(krange)",
        "body": "bexprnd",
        "description": "Exponential distribution random number generator."
    },
    "grain3": {
        "prefix": "grain3(kcps, kphs, kfmd, kpmd, kgdur, kdens, imaxovr, kfn, iwfn, kfrpow, kprpow [, iseed] [, imode])",
        "body": "grain3",
        "description": "Generate granular synthesis textures with more user control."
    },
    "pvinterp": {
        "prefix": "pvinterp(ktimpnt, kfmod, ifile, kfreqscale1, kfreqscale2, kampscale1, kampscale2, kfreqinterp, kampinterp)",
        "body": "pvinterp",
        "description": "Interpolates between the amplitudes and frequencies of two phase vocoder analysis files."
    },
    "trfilter": {
        "prefix": "trfilter(fin, kamnt, ifn)",
        "body": "trfilter",
        "description": "Streaming partial track filtering."
    },
    "midiout_i": {
        "prefix": "midiout_i(istatus, ichan, idata1, idata2)",
        "body": "midiout_i",
        "description": "Sends a generic MIDI message to the MIDI OUT port."
    },
    "ziwm": {
        "prefix": "ziwm(isig, indx [, imix])",
        "body": "ziwm",
        "description": "Writes to a zk variable to an i-rate variable with mixing."
    },
    "resonk": {
        "prefix": "resonk(ksig, kcf, kbw [, iscl] [, iskip])",
        "body": "resonk",
        "description": "A second-order resonant filter."
    },
    "k": {
        "prefix": "k(x)",
        "body": "k",
        "description": "Converts a i-rate parameter to an k-rate value or an a-rate value to a k-rate value by down-sampling."
    },
    ">": {
        "prefix": "(a >  b ? v1 : v2)",
        "body": ">",
        "description": "Determines if one value is greater than another."
    },
    "cntReset": {
        "prefix": "cntReset(icnt)",
        "body": "cntReset",
        "description": "Resets a counter object to its initial state."
    },
    "fout": {
        "prefix": "fout(ifilename, iformat, aout1 [, aout2, aout3,...,aoutN])",
        "body": "fout",
        "description": "Outputs a-rate signals to a specified file of an arbitrary number of channels."
    },
    "OSCsend": {
        "prefix": "OSCsend(kwhen, ihost, iport, idestination [, itype , xdata1, xdata2, ...])",
        "body": "OSCsend",
        "description": "Sends data to other listening processes using the OSC protocol."
    },
    "syncgrain": {
        "prefix": "syncgrain(kamp, kfreq, kpitch, kgrsize, kprate, ifun1, ifun2, iolaps)",
        "body": "syncgrain",
        "description": "Synchronous granular synthesis."
    },
    "outipb": {
        "prefix": "outipb(ichn, ivalue, imin, imax)",
        "body": "outipb",
        "description": "Sends MIDI pitch-bend messages at i-rate."
    },
    "vexpv": {
        "prefix": "vexpv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vexpv",
        "description": "Performs exponential operations between two vectorial control signals."
    },
    "cossegb": {
        "prefix": "cossegb(ia, itim1, ib [, itim2] [, ic] [...])",
        "body": "cossegb",
        "description": "Trace a series of line segments between specified absolute points with"
    },
    "jspline": {
        "prefix": "jspline({x, k}amp, kcpsMin, kcpsMax)",
        "body": "jspline",
        "description": "A jitter-spline generator."
    },
    "strcpy": {
        "prefix": "strcpy(Ssrc)",
        "body": "strcpy",
        "description": "Assign to a string variable by copying the source which may be a constant or another string variable."
    },
    "randc": {
        "prefix": "randc({x, k}amp, xcps [, iseed] [, isize] [, ioffset])",
        "body": "randc",
        "description": "Generates a controlled random number series with cubic interpolation between each new number."
    },
    "cntDelete_i": {
        "prefix": "cntDelete_i(icnt)",
        "body": "cntDelete_i",
        "description": "Delete a counter."
    },
    "deltapxw": {
        "prefix": "deltapxw(ain, adel, iwsize)",
        "body": "deltapxw",
        "description": "Mixes the input signal to a delay line."
    },
    "rand": {
        "prefix": "rand(xamp [, iseed] [, isel] [, ioffset])",
        "body": "rand",
        "description": "Output is a controlled random number series between -*amp* and +*amp*."
    },
    "min": {
        "prefix": "min({i, a, k}in1, ain2 [, ain3] [, ain4] [...])",
        "body": "min",
        "description": "Produces a signal that is the minimum of any number of input signals."
    },
    "until": {
        "prefix": "until condition do",
        "body": "until",
        "description": "A syntactic looping construction."
    },
    "tempoval": {
        "prefix": "tempoval()",
        "body": "tempoval",
        "description": "Reads the current value of the tempo."
    },
    "pvsin": {
        "prefix": "pvsin(kchan [, isize, iolap, iwinsize, iwintype, iformat])",
        "body": "pvsin",
        "description": "Retrieve an fsig from the input software bus; a pvs equivalent to _chani_."
    },
    "granule": {
        "prefix": "granule(xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec [, iseed] [, ipitch1] [, ipitch2] [, ipitch3] [, ipitch4] [, ifnenv])",
        "body": "granule",
        "description": "A more complex granular synthesis texture generator."
    },
    "lpreson": {
        "prefix": "lpreson(asig)",
        "body": "lpreson",
        "description": "RResynthesises a signal from the data passed internally by a previous _lpread_."
    },
    "mode": {
        "prefix": "mode(ain, xfreq, xQ [, iskip])",
        "body": "mode",
        "description": "A filter that simulates a mass-spring-damper system."
    },
    "atone": {
        "prefix": "atone(asig, khp [, iskip])",
        "body": "atone",
        "description": "A hi-pass filter whose transfer functions are the complements of the [tone] opcode."
    },
    "strset": {
        "prefix": "strset(iarg, istring)",
        "body": "strset",
        "description": "Allows a string to be linked with a numeric value."
    },
    "specdiff": {
        "prefix": "specdiff(wsigin)",
        "body": "specdiff",
        "description": "Finds the positive difference values between consecutive spectral frames."
    },
    "while": {
        "prefix": "while condition do",
        "body": "while",
        "description": "A syntactic looping construction."
    },
    "pvsfromarray": {
        "prefix": "pvsfromarray({t, k}var|karr[] [, ihopsize, iwinsize, iwintype])",
        "body": "pvsfromarray",
        "description": "Copies spectral data from k-rate arrays (or t-variables.). Also known as _pvsfromarray_."
    },
    "statevar": {
        "prefix": "statevar(ain, xcf, xq [, iosamps, istor])",
        "body": "statevar",
        "description": "Statevar is a new digital implementation of the analogue state-variable filter."
    },
    "pwd": {
        "prefix": "pwd()",
        "body": "pwd",
        "description": "Asks the underlying operating system for the current directory (folder) name as a string."
    },
    "valpass": {
        "prefix": "valpass(asig, krvt, xlpt, imaxlpt [, iskip] [, insmps])",
        "body": "valpass",
        "description": "Variably reverberates an input signal with a flat frequency response."
    },
    "in32": {
        "prefix": "in32()",
        "body": "in32",
        "description": "Reads a 32-channel audio signal from an external device or stream."
    },
    "r2c": {
        "prefix": "r2c(kin[])",
        "body": "r2c",
        "description": "Real to complex format conversion."
    },
    "lposcila": {
        "prefix": "lposcila(aamp, kfreqratio, kloop, kend, ift [,iphs])",
        "body": "lposcila",
        "description": "Read sampled sound from a table with looping and high precision."
    },
    "initc14": {
        "prefix": "initc14(ichan, ictlno1, ictlno2, ivalue)",
        "body": "initc14",
        "description": "Initializes the controllers used to create a 14-bit MIDI value."
    },
    "triglinseg": {
        "prefix": "triglinseg(kTrig, ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "triglinseg",
        "description": "Triggers a series of line segments between specified points."
    },
    "gtf": {
        "prefix": "gtf(ain, kfreq, ideca [, iorder, iphase])",
        "body": "gtf",
        "description": "Apply a gammatone filter of various orders to an audio signal."
    },
    "peak": {
        "prefix": "peak({a, k}sig)",
        "body": "peak",
        "description": "Maintains the output equal to the highest absolute value received."
    },
    "tempo": {
        "prefix": "tempo(ktempo, istartempo)",
        "body": "tempo",
        "description": "Apply tempo control to an uninterpreted score."
    },
    "dctinv": {
        "prefix": "dctinv({i, k}in[])",
        "body": "dctinv",
        "description": "Inverse Discrete Cosine Transform of a sample array (type-III DCT)."
    },
    "tab2pvs": {
        "prefix": "tab2pvs({t, k}var|karr[] [, ihopsize, iwinsize, iwintype])",
        "body": "tab2pvs",
        "description": "Copies spectral data from k-rate arrays (or t-variables.). Also known as _pvsfromarray_."
    },
    "outall": {
        "prefix": "outall(asig)",
        "body": "outall",
        "description": "Writes a single audio value to all available audio channels."
    },
    "midifilestatus": {
        "prefix": "midifilestatus([id:k])",
        "body": "midifilestatus",
        "description": "Returns the playback status of MIDI file input."
    },
    "moogvcf2": {
        "prefix": "moogvcf2(asig, xfco, xres [,iscale, iskip])",
        "body": "moogvcf2",
        "description": "A digital emulation of the Moog diode ladder filter configuration."
    },
    "nreverb": {
        "prefix": "nreverb(asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] [, inumAlpas] [, ifnAlpas])",
        "body": "nreverb",
        "description": "A reverberator consisting of 6 parallel comb-lowpass filters."
    },
    "slider32f": {
        "prefix": "slider32f(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ..., ictlnum32, imin32, imax32, init32, ifn32, icutoff32)",
        "body": "slider32f",
        "description": "Creates a bank of 32 different MIDI control message numbers, filtered before output."
    },
    "outc": {
        "prefix": "outc(asig1 [, asig2] [...])",
        "body": "outc",
        "description": "Writes audio data with an arbitrary number of channels to an external device or stream."
    },
    "planet": {
        "prefix": "planet(kmass1, kmass2, ksep, ix, iy, iz, ivx, ivy, ivz, idelta [, ifriction] [, iskip])",
        "body": "planet",
        "description": "Simulates a planet orbiting in a binary star system."
    },
    "endin": {
        "prefix": "endin",
        "body": "endin",
        "description": "Ends the current instrument block."
    },
    "mididefault": {
        "prefix": "mididefault(xdefault, xvalue)",
        "body": "mididefault",
        "description": "Changes values, depending on MIDI activation."
    },
    "wgpluck2": {
        "prefix": "wgpluck2(iplk, kamp, icps, kpick, krefl)",
        "body": "wgpluck2",
        "description": "Physical model of the plucked string."
    },
    "butterlp": {
        "prefix": "butterlp(asig, kfreq [, iskip])",
        "body": "butterlp",
        "description": "A low-pass Butterworth filter."
    },
    "writescratch": {
        "prefix": "writescratch(ival [index])",
        "body": "writescratch",
        "description": "Writes one of four scalar values into the scratchpad of the instance of an instrument."
    },
    "loop_ge": {
        "prefix": "loop_ge({i, k}ndx, idecr, imin, label)",
        "body": "loop_ge",
        "description": "Construction of looping operations."
    },
    "chani": {
        "prefix": "chani(kchan)",
        "body": "chani",
        "description": "Reads data from a channel of the inward software bus."
    },
    "pchmidi": {
        "prefix": "pchmidi()",
        "body": "pchmidi",
        "description": "Get the note number of the current MIDI event, expressed in pitch-class units."
    },
    "#undef": {
        "prefix": "#undef NAME",
        "body": "#undef",
        "description": "Un-defines a macro."
    },
    "sortd": {
        "prefix": "sortd(k/i[])",
        "body": "sortd",
        "description": "Takes a numeric array (k or i-rate) and returns it sorted in descending order."
    },
    "lphasor": {
        "prefix": "lphasor(xtrns [, ilps] [, ilpe] [, imode] [, istrt] [, istor])",
        "body": "lphasor",
        "description": "Generates a table index for sample playback (e.g. with [tablexkt])."
    },
    "\\$NAME": {
        "prefix": "\\$NAME",
        "body": "\\$NAME",
        "description": "Calls a defined macro."
    },
    "noteondur": {
        "prefix": "noteondur(ichn, inum, ivel, idur)",
        "body": "noteondur",
        "description": "Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity."
    },
    "mvchpf": {
        "prefix": "mvchpf(ain, xc [, istor])",
        "body": "mvchpf",
        "description": "Moog voltage-controlled highpass filter emulation."
    },
    "taninv2": {
        "prefix": "ares taninv2 ay, ax",
        "body": "taninv2",
        "description": "Returns the arctangent of _iy/ix_, _ky/kx_, or _ay/ax_."
    },
    "vibr": {
        "prefix": "vibr(kAverageAmp, kAverageFreq, ifn)",
        "body": "vibr",
        "description": "Easier-to-use user-controllable vibrato."
    },
    "pchmidib": {
        "prefix": "pchmidib([irange])",
        "body": "pchmidib",
        "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in pitch-class units."
    },
    "joystick": {
        "prefix": "joystick(kdevice, ktab)",
        "body": "joystick",
        "description": "Reads data from a Linux joystick controller."
    },
    "tablecopy": {
        "prefix": "tablecopy(kdft, ksft)",
        "body": "tablecopy",
        "description": "Simple, fast table copy opcode."
    },
    "rewindscore": {
        "prefix": "rewindscore()",
        "body": "rewindscore",
        "description": "Rewinds the playback position of the current score performance."
    },
    "continue": {
        "prefix": "continue",
        "body": "continue",
        "description": "A syntactic looping construction used in for, while, and until loops."
    },
    "repluck": {
        "prefix": "repluck(iplk, kamp, icps, kpick, krefl, axcite)",
        "body": "repluck",
        "description": "Physical model of the plucked string."
    },
    "logbtwo": {
        "prefix": "logbtwo(x)",
        "body": "logbtwo",
        "description": "Performs a logarithmic base two calculation."
    },
    "flooper": {
        "prefix": "flooper(kamp, kpitch, istart, idur, ifad, ifn)",
        "body": "flooper",
        "description": "Function-table-based crossfading looper."
    },
    "tablewa": {
        "prefix": "tablewa(kfn, asig, koff)",
        "body": "tablewa",
        "description": "Writes tables in sequential locations to and from an a-rate variable."
    },
    "tableigpw": {
        "prefix": "tableigpw(ifn)",
        "body": "tableigpw",
        "description": "Writes a table&#x27;s guard point."
    },
    "outletf": {
        "prefix": "outletf(Sname, fsignal)",
        "body": "outletf",
        "description": "Sends a frate signal (fsig) out from an instrument to a named port."
    },
    "strrindex": {
        "prefix": "strrindex(S1, S2)",
        "body": "strrindex",
        "description": "Return the position of the last occurence of S2 in S1, or -1 if not found. If S2 is empty, the length of S1 is returned."
    },
    "strindexk": {
        "prefix": "strindexk(S1, S2)",
        "body": "strindexk",
        "description": "Return the position of the first occurence of S2 in S1, or -1 if not found. If S2 is empty, 0 is returned."
    },
    "vbaplsinit": {
        "prefix": "vbaplsinit(idim, ilsnum [, idir1] [, idir2] [...] [, idir32])",
        "body": "vbaplsinit",
        "description": "Configures VBAP output according to loudspeaker parameters."
    },
    "ATSreadnz": {
        "prefix": "ATSreadnz(ktimepnt, iatsfile, iband)",
        "body": "ATSreadnz",
        "description": "reads data from an ATS file."
    },
    "vbap16move": {
        "prefix": "vbap16move(asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...])",
        "body": "vbap16move",
        "description": "Distribute an audio signal among 16 channels with moving virtual sources."
    },
    "zar": {
        "prefix": "zar(kndx)",
        "body": "zar",
        "description": "Reads from a location in za space at a-rate."
    },
    "balance2": {
        "prefix": "balance2(asig, acomp [, ihp] [, iskip])",
        "body": "balance2",
        "description": "Adjust one audio signal according to the values of another."
    },
    "round": {
        "prefix": "round(x)",
        "body": "round",
        "description": "Returns the integer value nearest to _x_."
    },
    "vps": {
        "prefix": "vps(aph,kd,kv)",
        "body": "vps",
        "description": "Shapes a phase signal according to a two-dimensional vector."
    },
    "imag": {
        "prefix": "imag(var:Complex)",
        "body": "imag",
        "description": "Returns the imaginary part of a complex number."
    },
    "slider32tablef": {
        "prefix": "slider32tablef(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ...., ictlnum32, imin32, imax32, init32, ifn32, icutoff32)",
        "body": "slider32tablef",
        "description": "Stores a bank of 32 different MIDI control messages to a table, filtered before output."
    },
    "igoto": {
        "prefix": "igoto(label)",
        "body": "igoto",
        "description": "During the i-time pass only, unconditionally transfer control to the statement labeled by _label_."
    },
    "ftom": {
        "prefix": "ftom({i, k}freq [,irnd])",
        "body": "ftom",
        "description": "Convert frequency to midi note number, taking global value of A4 into account."
    },
    "spectrum": {
        "prefix": "spectrum(xsig, iprd, iocts, ifrqa [, iq] [, ihann] [, idbout] [, idsprd] [, idsinrs])",
        "body": "spectrum",
        "description": "Generate a constant-Q, exponentially-spaced DFT across all octaves of a multiply-downsampled control or audio input signal."
    },
    "alpass": {
        "prefix": "alpass(asig, xrvt, ilpt [, iskip] [, insmps])",
        "body": "alpass",
        "description": "Reverberates an input signal with a flat frequency response."
    },
    "#ifndef": {
        "prefix": "#ifndef NAME",
        "body": "#ifndef",
        "description": "Conditional reading of code."
    },
    "pvsdisp": {
        "prefix": "pvsdisp(fsig [, ibins, iwtflg])",
        "body": "pvsdisp",
        "description": "Displays a PVS signal as an amplitude vs. freq graph."
    },
    "instr": {
        "prefix": "instr i, j, ...",
        "body": "instr",
        "description": "Starts an instrument block."
    },
    "seed": {
        "prefix": "seed(ival)",
        "body": "seed",
        "description": "Sets the global seed value for all _x-class noise generators_, as well as other opcodes that use a random call, such as [grain]."
    },
    "sfpassign": {
        "prefix": "sfpassign(istartindex, ifilhandl [, imsgs])",
        "body": "sfpassign",
        "description": "Assigns all presets of a SoundFont2 (SF2) sample file to a sequence of progressive index numbers."
    },
    "rezzy": {
        "prefix": "rezzy(asig, xfco, xres [, imode, iskip])",
        "body": "rezzy",
        "description": "A resonant low-pass filter."
    },
    "K35_lpf": {
        "prefix": "K35_lpf(ain, xcf, xQ [, inlp, isaturation, istor])",
        "body": "K35_lpf",
        "description": "Zero-delay feedback implementation of Korg35 resonant low-pass filter."
    },
    "pinkish": {
        "prefix": "pinkish(xin [, imethod] [, inumbands] [, iseed] [, iskip])",
        "body": "pinkish",
        "description": "Generates approximate pink noise (-3dB/oct response)."
    },
    "~": {
        "prefix": "~ a  (bitwise NOT)",
        "body": "~",
        "description": "Bitwise NOT operator."
    },
    "button": {
        "prefix": "button(knum)",
        "body": "button",
        "description": "Sense on-screen controls. Requires Winsound or TCL/TK."
    },
    "OSCcount": {
        "prefix": "OSCcount()",
        "body": "OSCcount",
        "description": "Gives the Count of OSC messages currently unread but received by the current listeners."
    },
    "qinf": {
        "prefix": "qinf(x)",
        "body": "qinf",
        "description": "Returns the number of times the argument is not a number, with the sign of the first infinity."
    },
    "serialRead": {
        "prefix": "serialRead(iPort)",
        "body": "serialRead",
        "description": "Read data from a serial port for arduino."
    },
    "rect2pol": {
        "prefix": "rect2pol(kin[])",
        "body": "rect2pol",
        "description": "Converts an input array in real-imaginary format to magnitude-phase format."
    },
    "vaddv_i": {
        "prefix": "vaddv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vaddv_i",
        "description": "Performs addition between two vectorial control signals at init time."
    },
    "outs2": {
        "prefix": "outs2(asig)",
        "body": "outs2",
        "description": "Writes samples to stereo channel 2 of an external device or stream."
    },
    "ampmidid": {
        "prefix": "ampmidid({i, k}velocity, idecibels)",
        "body": "ampmidid",
        "description": "Musically map MIDI velocity to peak amplitude within a specified dynamic range in decibels."
    },
    "stix": {
        "prefix": "stix(iamp, idettack [, inum] [, idamp] [, imaxshake])",
        "body": "stix",
        "description": "Semi-physical model of a stick sound."
    },
    "strlowerk": {
        "prefix": "strlowerk(Ssrc)",
        "body": "strlowerk",
        "description": "Convert Ssrc to lower case, and write the result to Sdst."
    },
    "zdf_2pole": {
        "prefix": "zdf_2pole(ain, xcf, xQ [, kmode, istor])",
        "body": "zdf_2pole",
        "description": "Zero-delay feedback implementation of a 2 pole (12 dB/oct) filter."
    },
    "cpumeter": {
        "prefix": "cpumeter(ifreq)",
        "body": "cpumeter",
        "description": "Reports the usage of cpu either total or per core to monitor how close to max-out the processing is."
    },
    "scanu2": {
        "prefix": "scanu2(init, irate, ifndisplace,ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id)",
        "body": "scanu2",
        "description": "Compute the waveform and the wavetable for use in scanned synthesis."
    },
    "readclock": {
        "prefix": "readclock(inum)",
        "body": "readclock",
        "description": "Reads the value of an internal clock."
    },
    "scale": {
        "prefix": "scale(kinput, kmax, kmi [, kimax, kimin])",
        "body": "scale",
        "description": "Arbitrary signal scaling."
    },
    "hrtfreverb": {
        "prefix": "hrtfreverb(asrc, ilowrt60, ihighrt60, ifilel, ifiler [,isr, imfp, iorder])",
        "body": "hrtfreverb",
        "description": "A binaural, dynamic FDN based diffuse-field reverberator. The opcode works independently as an efficient, flexible reverberator."
    },
    "mvclpf1": {
        "prefix": "mvclpf1(ain, xcf, xres[,istor])",
        "body": "mvclpf1",
        "description": "Moog voltage-controlled lowpass filter emulation."
    },
    "denorm": {
        "prefix": "denorm(a [, a [, a [, ... ]]])",
        "body": "denorm",
        "description": "Mixes low level (~1e-20 for floats, and ~1e-56 for doubles) noise to a list of a-rate signals."
    },
    "ftconv": {
        "prefix": "ftconv(ain, ift, iple [, iskipsamples [, iirle [, iskipinit]]])",
        "body": "ftconv",
        "description": "Low latency multichannel convolution, using a function table as impulse response source."
    },
    "lowpass2": {
        "prefix": "lowpass2(asig, kcf, kq [, iskip])",
        "body": "lowpass2",
        "description": "A resonant second-order lowpass filter."
    },
    "copyf2array": {
        "prefix": "copyf2array(tab, kftbl)",
        "body": "copyf2array",
        "description": "The _copyf2array_ opcode takes an f-table and copies the contents to a t-var."
    },
    "pvcross": {
        "prefix": "pvcross(ktimpnt, kfmod, ifile, kampscale1, kampscale2 [, ispecwp])",
        "body": "pvcross",
        "description": "Applies the amplitudes from one phase vocoder analysis file to the data from a second file and then performs the resynthesis."
    },
    "cbrt": {
        "prefix": "cbrt({i, k}arg)",
        "body": "cbrt",
        "description": "Cubic root function."
    },
    "clfilt": {
        "prefix": "clfilt(asig, kfreq, itype, inpol [, ikind] [, ipbr] [, isba] [, iskip])",
        "body": "clfilt",
        "description": "Implements the classical standard analog filter types: low-pass and high-pass."
    },
    "zkmod": {
        "prefix": "zkmod(ksig, kzkmod)",
        "body": "zkmod",
        "description": "Facilitates the modulation of one signal by another."
    },
    "wgclar": {
        "prefix": "wgclar(kamp, kfreq, kstiff, iatt, idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq])",
        "body": "wgclar",
        "description": "Creates a tone similar to a clarinet."
    },
    "%": {
        "prefix": "a % b  (no rate restriction)",
        "body": "%",
        "description": "Modulus operator."
    },
    "midic7": {
        "prefix": "midic7(ictlno, imin, imax [, ifn])",
        "body": "midic7",
        "description": "Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "outh": {
        "prefix": "outh(asig1, asig2, asig3, asig4, asig5, asig6)",
        "body": "outh",
        "description": "Writes 6-channel audio data to an external device or stream."
    },
    "sumarray": {
        "prefix": "sumarray(karray)",
        "body": "sumarray",
        "description": "Returns the sum of all elements in a k-rate array."
    },
    "xout": {
        "prefix": "xout(xoutarg1 [, xoutarg2] ... [, xoutargN])",
        "body": "xout",
        "description": "Retrieves variables from a user-defined opcode block."
    },
    "loop_lt": {
        "prefix": "loop_lt({i, k}ndx, incr, imax, label)",
        "body": "loop_lt",
        "description": "Construction of looping operations."
    },
    "pop": {
        "prefix": "pop()",
        "body": "pop",
        "description": "Pops values from the global stack.  Deprecated."
    },
    "crunch": {
        "prefix": "crunch(iamp, idettack [, inum] [, idamp] [, imaxshake])",
        "body": "crunch",
        "description": "Semi-physical model of a crunch sound."
    },
    "int": {
        "prefix": "int(x)",
        "body": "int",
        "description": "Extracts an integer from a decimal number."
    },
    "strtodk": {
        "prefix": "strtodk({k, S}str)",
        "body": "strtodk",
        "description": "Converts a string to a floating point value at i- or k-rate."
    },
    "OSClisten": {
        "prefix": "OSClisten(ihandle, idest, itype [, xdata1, xdata2, ...])",
        "body": "OSClisten",
        "description": "Listen for OSC messages to a particular path, either from a custom-defined OSC server or from the Csound UDP server."
    },
    "conj": {
        "prefix": "conj(var:Complex)",
        "body": "conj",
        "description": "Returns a complex number, optionally in polar form."
    },
    "sininv": {
        "prefix": "sininv(x)",
        "body": "sininv",
        "description": "Returns the arcsine of _x_ (_x_ in radians)."
    },
    "part2txt": {
        "prefix": "part2txt(SFile, ftrks)",
        "body": "part2txt",
        "description": "Write a text file containing partial tracks data."
    },
    "cntDelete": {
        "prefix": "cntDelete(icnt)",
        "body": "cntDelete",
        "description": "Delete a counter and render any memory used."
    },
    "sleighbells": {
        "prefix": "sleighbells(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1] [, ifreq2])",
        "body": "sleighbells",
        "description": "Semi-physical model of a sleighbell sound."
    },
    "!=": {
        "prefix": "(a != b ? v1 : v2)",
        "body": "!=",
        "description": "Determines if one value is not equal to another."
    },
    "moogvcf": {
        "prefix": "moogvcf(asig, xfco, xres [,iscale, iskip])",
        "body": "moogvcf",
        "description": "A digital emulation of the Moog diode ladder filter configuration."
    },
    "return": {
        "prefix": "return(ival)",
        "body": "return",
        "description": "Returns a value from an instrument at i-time."
    },
    "OSCinitM": {
        "prefix": "OSCinitM(Sgroup, iport)",
        "body": "OSCinitM",
        "description": "Start a multicast listening process to a particular port, which can be used by OSClisten."
    },
    "midifilepos": {
        "prefix": "midifilepos({pos: [, id:i], [id:i], pos: [, id:i]})",
        "body": "midifilepos",
        "description": "Gets/Sets the playback position of a MIDI file. "
    },
    "buzz": {
        "prefix": "buzz(xamp, xcps, knh, ifn [, iphs])",
        "body": "buzz",
        "description": "Output is a set of harmonically related sine partials."
    },
    "mvmfilter": {
        "prefix": "mvmfilter(ain, xfreq, xTau [, iskip])",
        "body": "mvmfilter",
        "description": "A filter with pronounced resonance and controllable decay time."
    },
    "octave": {
        "prefix": "octave(x)",
        "body": "octave",
        "description": "Calculates a factor to raise/lower a frequency by a given amount of octaves."
    },
    "strcatk": {
        "prefix": "strcatk(Ssrc1, Ssrc2)",
        "body": "strcatk",
        "description": "Concatenate two strings and store the result in a variable."
    },
    "oscil1": {
        "prefix": "oscil1(idel, kamp, idur [, ifn])",
        "body": "oscil1",
        "description": "Accesses table values by incremental sampling."
    },
    "<": {
        "prefix": "(a <  b ? v1 : v2)",
        "body": "<",
        "description": "Determines if one value is less than another."
    },
    "ampmidi": {
        "prefix": "ampmidi(iscal [, ifn])",
        "body": "ampmidi",
        "description": "Get the velocity of the current MIDI event."
    },
    "sense": {
        "prefix": "sense()",
        "body": "sense",
        "description": "Returns the ASCII code of a key that has been pressed, or -1 if no key has been pressed."
    },
    "compilestr": {
        "prefix": "compilestr(Sorch)",
        "body": "compilestr",
        "description": "Compiles a new orchestra passed in as an ASCII string."
    },
    "filevalid": {
        "prefix": "filevalid(ifilcod)",
        "body": "filevalid",
        "description": "Checks that a file can be read at initialisation or performance time."
    },
    "bbcutm": {
        "prefix": "bbcutm(asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats [, istutterspeed] [, istutterchance] [, ienvchoice ])",
        "body": "bbcutm",
        "description": "Generates breakbeat-style cut-ups of a mono audio stream."
    },
    "strchark": {
        "prefix": "strchark(Sstr [, kpos])",
        "body": "strchark",
        "description": "Return the ASCII code of the character in Sstr at kpos (defaults to zero which means the first character), or zero if kpos is out of range."
    },
    "wgbowedbar": {
        "prefix": "wgbowedbar(kamp, kfreq, kpos, kbowpres, kgain [, iconst] [, itvel] [, ibowpos] [, ilow])",
        "body": "wgbowedbar",
        "description": "A physical model of a bowed bar."
    },
    "pvs2array": {
        "prefix": "pvs2array({t, k}var|kvar[], fsig)",
        "body": "pvs2array",
        "description": "Copies spectral data to k-rate arrays (or t-variables). Also known as [pvs2array](pvs2array.md)."
    },
    "exp": {
        "prefix": "exp({a,k,i,Complex})",
        "body": "exp",
        "description": "Returns e raised to the xth power."
    },
    "&": {
        "prefix": "a & b  (bitwise AND)",
        "body": "&",
        "description": "Bitwise AND operator."
    },
    "balance": {
        "prefix": "balance(asig, acomp [, ihp] [, iskip])",
        "body": "balance",
        "description": "Adjust one audio signal according to the values of another."
    },
    "vtablewa": {
        "prefix": "vtablewa(andx, kfn, ixmode, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ])",
        "body": "vtablewa",
        "description": "Write vectors (to tables -or arrays of vectors) at a-rate."
    },
    "freeverb": {
        "prefix": "freeverb(ainL, ainR, kRoomSize, kHFDam [, iSRat [, iSkip]])",
        "body": "freeverb",
        "description": "Opcode version of Jezar&#x27;s Freeverb."
    },
    "p": {
        "prefix": "p(x)",
        "body": "p",
        "description": "Show the value in a given p-field."
    },
    "exprand": {
        "prefix": "exprand(klambda)",
        "body": "exprand",
        "description": "Exponential distribution random number generator (positive values only)."
    },
    "vtablea": {
        "prefix": "vtablea(andx, kfn, kinterp, ixmode, aout1 [, aout2, aout3, .... , aoutN ])",
        "body": "vtablea",
        "description": "Read vectors (from tables -or arrays of vectors) at a-rate."
    },
    "mfb": {
        "prefix": "mfb(kin[], klow, khigh, ibands)",
        "body": "mfb",
        "description": "Mel scale filterbank for spectral magnitudes."
    },
    "date": {
        "prefix": "date()",
        "body": "date",
        "description": "Returns the number seconds since a base date, using the operating system&#x27;s clock."
    },
    "phaser2": {
        "prefix": "phaser2(asig, kfreq, kq, kord, kmode, ksep, kfeedback)",
        "body": "phaser2",
        "description": "Second-order allpass filters arranged in a series."
    },
    "nchnls": {
        "prefix": "nchnls = iarg",
        "body": "nchnls",
        "description": "Sets the number of channels of audio output."
    },
    "pvsblur": {
        "prefix": "pvsblur(fsigin, kblurtime, imaxdel)",
        "body": "pvsblur",
        "description": "Average the amp/freq time functions of each analysis channel for a specified time (truncated to number of frames)."
    },
    "vtabwk": {
        "prefix": "vtabwk(kndx, ifn, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ])",
        "body": "vtabwk",
        "description": "Write vectors (to tables -or arrays of vectors) at k-rate."
    },
    "harmon": {
        "prefix": "harmon(asig, kestfrq, kmaxvar, kgenfreq1, kgenfreq2, imode, iminfrq, iprd)",
        "body": "harmon",
        "description": "Analyze an audio input and generate harmonizing voices in synchrony."
    },
    "polynomial": {
        "prefix": "polynomial(ain, k0 [, k1 [, k2 [...]]])",
        "body": "polynomial",
        "description": "Efficiently evaluates a polynomial of arbitrary order."
    },
    "bqrez": {
        "prefix": "bqrez(asig, xfco, xres [, imode] [, iskip])",
        "body": "bqrez",
        "description": "A second-order multi-mode filter."
    },
    "out32": {
        "prefix": "out32(asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, asig10, asig11, asig12, asig13, asig14, asig15, asig16, asig17, asig18, asig19, asig20, asig21, asig22, asig23, asig24, asig25, asig26, asig27, asig28, asig29, asig30, asig31, asig32)",
        "body": "out32",
        "description": "Writes 32-channel audio data to an external device or stream."
    },
    "active": {
        "prefix": "active({i, k, S}nsnum [,iopt [,inorel]])",
        "body": "active",
        "description": "Returns the number of active instances of an instrument with options to ignore releasing instances."
    },
    "butbp": {
        "prefix": "butbp(asig, xfreq, xband [, iskip])",
        "body": "butbp",
        "description": "A band-pass Butterworth filter."
    },
    "midifilerewind": {
        "prefix": "midifilerewind([id:i])",
        "body": "midifilerewind",
        "description": "Rewinds playback of a MIDI file. "
    },
    "tablekt": {
        "prefix": "tablekt({x, k}ndx, kfn [, ixmode] [, ixoff] [, iwrap])",
        "body": "tablekt",
        "description": "Provides k-rate control over table numbers."
    },
    "sterrain": {
        "prefix": "sterrain(kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, km1, km2, kn1, kn2, kn3, ka, kb, kperiod)",
        "body": "sterrain",
        "description": "A wave-terrain synthesis opcode using curves computed with the superformula."
    },
    "if": {
        "prefix": "if ia R ib igoto label",
        "body": "if",
        "description": "Branches conditionally at initialization or during performance time."
    },
    "pvsadsyn": {
        "prefix": "pvsadsyn(fsrc, inoscs, kfmod [, ibinoffset] [, ibinincr] [, iinit])",
        "body": "pvsadsyn",
        "description": "Resynthesize using a fast oscillator-bank."
    },
    "genarray_i": {
        "prefix": "genarray_i(istart, iend [,inc])",
        "body": "genarray_i",
        "description": "Generate a vector (one-dimensional k-rate) with an arithmetic sequence at initialisation time."
    },
    "resonx": {
        "prefix": "resonx(asig, xcf, xbw [, inumlayer] [, iscl] [, iskip])",
        "body": "resonx",
        "description": "Emulates a stack of filters using the reson opcode."
    },
    "dumpk2": {
        "prefix": "dumpk2(ksig1, ksig2, ifilname, iformat, iprd)",
        "body": "dumpk2",
        "description": "Periodically writes two orchestra control-signal values to a named external file in a specific format."
    },
    "break": {
        "prefix": "break",
        "body": "break",
        "description": "A syntactic looping construction used in for, while, and until loops."
    },
    "octmidib": {
        "prefix": "octmidib([irange])",
        "body": "octmidib",
        "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in octave-point-decimal."
    },
    "strlower": {
        "prefix": "strlower(Ssrc)",
        "body": "strlower",
        "description": "Convert Ssrc to lower case, and write the result to Sdst."
    },
    "push": {
        "prefix": "push({x, i}val1, [xval2, ... , xval31])",
        "body": "push",
        "description": "Pushes a value into the global stack.  Deprecated."
    },
    "+=": {
        "prefix": "ares += xarg",
        "body": "+=",
        "description": "Performs add and assignment."
    },
    "trigger": {
        "prefix": "trigger(ksig, kthreshold, kmode)",
        "body": "trigger",
        "description": "Informs when a krate signal crosses a threshold."
    },
    "outiat": {
        "prefix": "outiat(ichn, ivalue, imin, imax)",
        "body": "outiat",
        "description": "Sends MIDI aftertouch messages at i-rate."
    },
    ">>": {
        "prefix": "a >> b  (bitshift left)",
        "body": ">>",
        "description": "Bitshift right operator."
    },
    "inletf": {
        "prefix": "inletf(Sname)",
        "body": "inletf",
        "description": "Receives an frate signal (fsig) into an instrument from a named port."
    },
    "loopsegp": {
        "prefix": "loopsegp(kphase, kvalue0, kdur0, kvalue1 [, kdur1, ... , kdurN-1, kvalueN])",
        "body": "loopsegp",
        "description": "Control signals based on linear segments."
    },
    "mac": {
        "prefix": "mac(ksig1, asig1 [, ksig2] [, asig2] [, ksig3] [, asig3] [...])",
        "body": "mac",
        "description": "Multiplies and accumulates a- and k-rate signals."
    },
    "pvsynth": {
        "prefix": "pvsynth(fsrc, [iinit])",
        "body": "pvsynth",
        "description": "Resynthesise phase vocoder data (f-signal) using a FFT overlap-add."
    },
    "soundout": {
        "prefix": "soundout(asig1, ifilcod [, iformat])",
        "body": "soundout",
        "description": "Deprecated. Writes audio output to a disk file."
    },
    "pvspitch": {
        "prefix": "pvspitch(fsig, kthresh)",
        "body": "pvspitch",
        "description": "Track the pitch and amplitude of a PVS signal as k-rate variables."
    },
    "mton": {
        "prefix": "mton({i, k}midi)",
        "body": "mton",
        "description": "Convert midi note number to string note name, with an accuracy of 1 cent."
    },
    "pvscfs": {
        "prefix": "pvscfs(fsig, iord [, imod])",
        "body": "pvscfs",
        "description": "Cepstrum all-pole coefficient analysis."
    },
    "fin": {
        "prefix": "fin(ifilename, iskipframes, iformat, ain1 [, ain2] [, ain3] [,...])",
        "body": "fin",
        "description": "Read signals from a file at a-rate."
    },
    "trmix": {
        "prefix": "trmix(fin1, fin2)",
        "body": "trmix",
        "description": "Streaming partial track mixing."
    },
    "hvs2": {
        "prefix": "hvs2(kx, ky, inumParms, inumPointsX, inumPointsY, iOutTab, iPositionsTab, iSnapTab [, iConfigTab])",
        "body": "hvs2",
        "description": "Allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables."
    },
    "cpsmidinn": {
        "prefix": "cpsmidinn(MidiNoteNumber)",
        "body": "cpsmidinn",
        "description": "Converts a Midi note number value to cycles-per-second."
    },
    "ksmps": {
        "prefix": "ksmps = iarg",
        "body": "ksmps",
        "description": "Sets the number of samples in a control period."
    },
    "pvs2tab": {
        "prefix": "pvs2tab({t, k}var|kvar[], fsig)",
        "body": "pvs2tab",
        "description": "Copies spectral data to k-rate arrays (or t-variables). Also known as [pvs2array](pvs2array.md)."
    },
    "cpuprc": {
        "prefix": "cpuprc({i, S}nsnum, ipercent)",
        "body": "cpuprc",
        "description": "Control allocation of cpu resources on a per-instrument basis, to optimize realtime output."
    },
    "lpcanal": {
        "prefix": "lpcanal({i, a, k}src, kflg, kprd, isiz, iord [, iwin])",
        "body": "lpcanal",
        "description": "Streaming linear prediction analysis."
    },
    "schedulek": {
        "prefix": "schedulek(knsnum, kwhen, kdur [, kp4] [, kp5] [...])",
        "body": "schedulek",
        "description": "Adds a new score event."
    },
    "transegb": {
        "prefix": "transegb(ia, itim, itype, ib [, itim2] [, itype] [, ic] ...)",
        "body": "transegb",
        "description": "Constructs a user-definable envelope in absolute time."
    },
    "loopxseg": {
        "prefix": "loopxseg(kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...])",
        "body": "loopxseg",
        "description": "Generate control signal consisting of exponential segments delimited by two or more specified points."
    },
    "sin": {
        "prefix": "sin(x)",
        "body": "sin",
        "description": "Returns the sine of _x_ (_x_ in radians)."
    },
    "strsub": {
        "prefix": "strsub(Ssrc [, istar [, iend]])",
        "body": "strsub",
        "description": "Extract a substring of the source string."
    },
    "vmult_i": {
        "prefix": "vmult_i(ifn, ival, ielements [, idstoffset])",
        "body": "vmult_i",
        "description": "Multiplies a vector in a table by a scalar value."
    },
    "inh": {
        "prefix": "inh()",
        "body": "inh",
        "description": "Reads six-channel audio data from an external device or stream."
    },
    "vlimit": {
        "prefix": "vlimit(ifn, kmin, kmax, ielements)",
        "body": "vlimit",
        "description": "Limits elements of vectorial control signals."
    },
    "arduinoStart": {
        "prefix": "arduinoStart(SPortName [, ibaudRate])",
        "body": "arduinoStart",
        "description": "Open a serial port for use with the Arduino protocol."
    },
    "tablexseg": {
        "prefix": "tablexseg(ifn1, idur1, ifn2 [, idur2] [, ifn3] [...])",
        "body": "tablexseg",
        "description": "Creates a new function table by making exponential segments between values in stored function tables."
    },
    "pvsmooth": {
        "prefix": "pvsmooth(fsigin, kacf, kfcf)",
        "body": "pvsmooth",
        "description": "Smooth the amplitude and frequency time functions of a pv stream using parallel 1st order lowpass IIR filters with time-varying cutoff frequency."
    },
    "dconv": {
        "prefix": "dconv(asig, isize, ifn)",
        "body": "dconv",
        "description": "A direct convolution opcode."
    },
    "ampdb": {
        "prefix": "ampdb(x)",
        "body": "ampdb",
        "description": "Returns the amplitude equivalent of the decibel value x. Thus:"
    },
    "lpread": {
        "prefix": "lpread(ktimpnt, ifilcod [, inpoles] [, ifrmrate])",
        "body": "lpread",
        "description": "Reads a control file of time-ordered information frames."
    },
    "count": {
        "prefix": "count(icnt)",
        "body": "count",
        "description": "Get the next value from a counter."
    },
    "fmpercfl": {
        "prefix": "fmpercfl(kamp, kfreq, kc1, kc2, kvdepth, kvrat [, ifn1, ifn2, ifn3, ifn4, ivfn])",
        "body": "fmpercfl",
        "description": "Uses FM synthesis to create a percussive flute sound."
    },
    "randh": {
        "prefix": "randh({x, k}amp, xcps [, iseed] [, isize] [, ioffset])",
        "body": "randh",
        "description": "Generates random numbers and holds them for a period of time."
    },
    "xtratim": {
        "prefix": "xtratim(iextradur)",
        "body": "xtratim",
        "description": "Extend the duration of real-time generated events and handle their extra life (Usually for usage along with [release], etc)."
    },
    "trcross": {
        "prefix": "trcross(fin1, fin2, ksearch, kdepth [, kmode])",
        "body": "trcross",
        "description": "Streaming partial track cross-synthesis."
    },
    "ftload": {
        "prefix": "ftload(Sfilename, iflag, ifn1 [, ifn2] [...])",
        "body": "ftload",
        "description": "Load a set of previously-allocated tables from a file."
    },
    "strcmp": {
        "prefix": "strcmp(S1, S2)",
        "body": "strcmp",
        "description": "Compare strings."
    },
    "checkbox": {
        "prefix": "checkbox(knum)",
        "body": "checkbox",
        "description": "Sense on-screen controls. Requires Winsound or TCL/TK."
    },
    "reverbsc": {
        "prefix": "reverbsc(ainL, ainR, kfblvl, kfc [, israt [, ipitch [, iskip]]])",
        "body": "reverbsc",
        "description": "8 delay line stereo FDN reverb."
    },
    "powoftwo": {
        "prefix": "powoftwo(x)",
        "body": "powoftwo",
        "description": "Performs a  power-of-two calculation."
    },
    "midinoteoncps": {
        "prefix": "midinoteoncps(xcps, xvelocity)",
        "body": "midinoteoncps",
        "description": "Gets a MIDI note number as a cycles-per-second frequency."
    },
    "midifilemute": {
        "prefix": "midifilemute([id:i])",
        "body": "midifilemute",
        "description": "Toggle-mutes playback of a MIDI file (without pausing playback). "
    },
    "oscilikts": {
        "prefix": "oscilikts(xamp, xcps, kfn, async, kphs [, istor])",
        "body": "oscilikts",
        "description": "A linearly interpolated oscillator with sync status that allows changing the table number at k-rate."
    },
    "arduinoReadF": {
        "prefix": "arduinoReadF(iPort, iStream1, iStream2, iStream3)",
        "body": "arduinoReadF",
        "description": "Read integer data from an arduino port using the Csound-Arduino protocol."
    },
    "outq2": {
        "prefix": "outq2(asig)",
        "body": "outq2",
        "description": "Writes samples to quad channel 2 of an external device or stream."
    },
    "deltapi": {
        "prefix": "deltapi(xdlt)",
        "body": "deltapi",
        "description": "Taps a delay line at variable offset times, uses interpolation."
    },
    "maxarray": {
        "prefix": "maxarray(karray)",
        "body": "maxarray",
        "description": "Returns the maximum value in a k-rate array, and optional its index."
    },
    "fold": {
        "prefix": "fold(asig, kincr)",
        "body": "fold",
        "description": "Adds artificial foldover to an audio signal."
    },
    "vexpv_i": {
        "prefix": "vexpv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vexpv_i",
        "description": "Performs exponential operations between two vectorial control signals at init time."
    },
    "gendy": {
        "prefix": "gendy(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, kampscl, kdurscl [, initcps] [, knum])",
        "body": "gendy",
        "description": "Dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis."
    },
    "cosseg": {
        "prefix": "cosseg(ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "cosseg",
        "description": "Trace a series of line segments between specified points with cosine interpolation."
    },
    "seqtime2": {
        "prefix": "seqtime2(ktrig_in, ktime_unit, kstart, kloop, kinitndx, kfn_times)",
        "body": "seqtime2",
        "description": "Generates a trigger signal according to the values stored in a table."
    },
    "changed2": {
        "prefix": "changed2({a, k}var1 [, kvar2,..., kvarN])",
        "body": "changed2",
        "description": "k-rate signal change detector."
    },
    "pvsfread": {
        "prefix": "pvsfread(ktimpt, ifn [, ichan])",
        "body": "pvsfread",
        "description": "Read a selected channel from a PVOC-EX analysis file."
    },
    "interp": {
        "prefix": "interp(ksig [, iskip] [, imode] [, ivalue])",
        "body": "interp",
        "description": "Converts a control signal to an audio signal using linear interpolation."
    },
    "vpvoc": {
        "prefix": "vpvoc(ktimpnt, kfmod, ifile [, ispecwp] [, ifn])",
        "body": "vpvoc",
        "description": "Implements signal reconstruction using an fft-based phase vocoder and an extra envelope."
    },
    "elseif": {
        "prefix": "elseif xa R xb then",
        "body": "elseif",
        "description": "Defines another &quot;if...then&quot; condition when a &quot;if...then&quot; condition is false."
    },
    "pvsbufread": {
        "prefix": "pvsbufread(ktime, khandle [, ilo, ihi, iclear])",
        "body": "pvsbufread",
        "description": "This opcode reads a circular buffer of f-signals (streaming PV signals)."
    },
    "sndwarpst": {
        "prefix": "sndwarpst(xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, irandw, ioverlap, ifn2, itimemode)",
        "body": "sndwarpst",
        "description": "Reads a stereo sound sample from a table and applies time-stretching and/or pitch modification."
    },
    "resony": {
        "prefix": "resony(asig, kbf, kbw, inum, ksep [, isepmode] [, iscl] [, iskip])",
        "body": "resony",
        "description": "A bank of second-order bandpass filters, connected in parallel."
    },
    "mvclpf4": {
        "prefix": "mvclpf4(ain, xcf, xre [, istor])",
        "body": "mvclpf4",
        "description": "Moog voltage-controlled lowpass filter emulation."
    },
    "dumpk3": {
        "prefix": "dumpk3(ksig1, ksig2, ksig3, ifilname, iformat, iprd)",
        "body": "dumpk3",
        "description": "Periodically writes three orchestra control-signal values to a named external file in a specific format."
    },
    "pvsfwrite": {
        "prefix": "pvsfwrite(fsig, ifile)",
        "body": "pvsfwrite",
        "description": "Write a fsig to a PVOCEX file (which in turn can be read by _pvsfread_ or other programs that support PVOCEX file input)."
    },
    "sensekey": {
        "prefix": "sensekey()",
        "body": "sensekey",
        "description": "Returns the ASCII code of a key that has been pressed, or -1 if no key has been pressed."
    },
    "ftgenonce": {
        "prefix": "ftgenonce(ip1, ip2dummy, isize, igen, iarga, iargb, ...)",
        "body": "ftgenonce",
        "description": "Generate a function table from within an instrument definition, without duplication of data."
    },
    "midiprogramchange": {
        "prefix": "midiprogramchange(xprogram)",
        "body": "midiprogramchange",
        "description": "Gets a MIDI program change value."
    },
    "log2": {
        "prefix": "log2(x)",
        "body": "log2",
        "description": "Returns the base 2 log of _x_ (_x_ positive only)."
    },
    "slider16tablef": {
        "prefix": "slider16tablef(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ...., ictlnum16, imin16, imax16, init16, ifn16, icutoff16)",
        "body": "slider16tablef",
        "description": "Stores a bank of 16 different MIDI control messages to a table, filtered before output."
    },
    "trlowest": {
        "prefix": "trlowest(fin1, kscal)",
        "body": "trlowest",
        "description": "Extracts the lowest-frequency track from a streaming track input signal."
    },
    "select": {
        "prefix": "select(a1, a2, aless, aequal, amore)",
        "body": "select",
        "description": "Select sample value from three based on audio-rate comparisons of two signals."
    },
    "trirand": {
        "prefix": "trirand(krange)",
        "body": "trirand",
        "description": "Triangular distribution random number generator."
    },
    "inq": {
        "prefix": "inq()",
        "body": "inq",
        "description": "Reads quad audio data from an external device or stream."
    },
    "hvs3": {
        "prefix": "hvs3(kx, ky, kz, inumParms, inumPointsX, inumPointsY, inumPointsZ, iOutTab, iPositionsTab, iSnapTab [, iConfigTab])",
        "body": "hvs3",
        "description": "Allows three-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables."
    },
    "miditempo": {
        "prefix": "miditempo([id:i])",
        "body": "miditempo",
        "description": "Returns the current tempo at k-rate, of either the MIDI file (if available) or the score. (provided the -t option is used)."
    },
    "ftcps": {
        "prefix": "ftcps(x)",
        "body": "ftcps",
        "description": "Returns the base frequency of a stored function table in Hz."
    },
    "dot": {
        "prefix": "dot(karr1[]/iarr1[], karr2[]/iarr2[])",
        "body": "dot",
        "description": "Calculates the dot product of two arrays."
    },
    "sum": {
        "prefix": "sum({i, a, k}sig1 [, asig2] [, asig3] [...])",
        "body": "sum",
        "description": "Sums any number of a-rate signals, or array elements."
    },
    "loscil3": {
        "prefix": "loscil3(xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] [, imod2] [, ibeg2] [, iend2])",
        "body": "loscil3",
        "description": "Read sampled sound from a table using cubic interpolation."
    },
    "downsamp": {
        "prefix": "downsamp(asig [, iwlen])",
        "body": "downsamp",
        "description": "Modify a signal by down-sampling."
    },
    "space": {
        "prefix": "space(asig, ifn, ktime, kreverbsend, kx, ky)",
        "body": "space",
        "description": "Distributes an input signal among 4 channels using cartesian coordinates."
    },
    "st2ms": {
        "prefix": "st2ms(aleft,aright)",
        "body": "st2ms",
        "description": "Stereo to Mid-Side Conversion."
    },
    "distort1": {
        "prefix": "distort1(asig, kpregain, kpostgain, kshape1, kshape [, imode])",
        "body": "distort1",
        "description": "Modified hyperbolic tangent distortion."
    },
    "ctrlsave": {
        "prefix": "ctrlsave(ichnl, ictlno1, [ictlno2] [, ictlno3] ...)",
        "body": "ctrlsave",
        "description": "Recovers the current values of MIDI controllers to a k-array."
    },
    "initc7": {
        "prefix": "initc7(ichan, ictlno, ivalue)",
        "body": "initc7",
        "description": "Initializes the controller used to create a 7-bit MIDI value."
    },
    "midifileplay": {
        "prefix": "midifileplay([id:i])",
        "body": "midifileplay",
        "description": "Starts playback of a MIDI file. "
    },
    "directory": {
        "prefix": "directory(SDirectory [, SExtention])",
        "body": "directory",
        "description": "Reads a directory and outputs to a string array a list of file names."
    },
    "ftaudio": {
        "prefix": "ftaudio({i, k}fn, \"filename\", iforma [, ibeg, iend])",
        "body": "ftaudio",
        "description": "Write a previously-allocated table to an audio file in a variety of formats."
    },
    "expsega": {
        "prefix": "expsega(ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "expsega",
        "description": "An exponential segment generator operating at a-rate."
    },
    "strcmpk": {
        "prefix": "strcmpk(S1, S2)",
        "body": "strcmpk",
        "description": "Compare strings."
    },
    "readk": {
        "prefix": "readk(ifilname, iformat, iprd)",
        "body": "readk",
        "description": "Periodically reads an orchestra control-signal value from a named external file in a specific format."
    },
    "pan": {
        "prefix": "pan(asig, kx, ky, ifn [, imode] [, ioffset])",
        "body": "pan",
        "description": "Distribute an audio signal amongst four channels with localization control."
    },
    "ampdbfs": {
        "prefix": "ampdbfs(x)",
        "body": "ampdbfs",
        "description": "Returns the amplitude equivalent (in 16-bit signed integer scale) of the full scale decibel (dB FS) value _x_."
    },
    "zakinit": {
        "prefix": "zakinit(isizea, isizek)",
        "body": "zakinit",
        "description": "Establishes zak space. Must be called only once."
    },
    "waveset": {
        "prefix": "waveset(ain, krep [, ilen])",
        "body": "waveset",
        "description": "A simple time stretch by repeating cycles."
    },
    "schedule": {
        "prefix": "schedule(insnum, iwhen, idur [, ip4] [, ip5] [...])",
        "body": "schedule",
        "description": "Adds a new score event."
    },
    "fft": {
        "prefix": "fft({in:Complex[], in:k[], in:Complex[ [, inverse:i]})",
        "body": "fft",
        "description": "Complex-to-complex Fast Fourier Transform."
    },
    "vdelayxws": {
        "prefix": "vdelayxws(ain1, ain2, adl, imd, iws [, ist])",
        "body": "vdelayxws",
        "description": "Variable delay opcodes with high quality interpolation."
    },
    "noteoff": {
        "prefix": "noteoff(ichn, inum, ivel)",
        "body": "noteoff",
        "description": "Send a noteoff message to the MIDI OUT port."
    },
    "readk4": {
        "prefix": "readk4(ifilname, iformat, iprd)",
        "body": "readk4",
        "description": "Periodically reads four orchestra control-signal values from an external file."
    },
    "tableikt": {
        "prefix": "tableikt({x, k}ndx, kfn [, ixmode] [, ixoff] [, iwrap])",
        "body": "tableikt",
        "description": "Provides k-rate control over table numbers."
    },
    "specdisp": {
        "prefix": "specdisp(wsig, iprd [, iwtflg])",
        "body": "specdisp",
        "description": "Displays the magnitude values of the spectrum."
    },
    "insremot": {
        "prefix": "insremot(idestination, isource, instrnum [, instrnum...])",
        "body": "insremot",
        "description": "An opcode which can be used to implement a remote orchestra. This opcode will send note events from a source machine to one destination."
    },
    "hrtfstat": {
        "prefix": "hrtfstat(asrc, iAz, iElev, ifilel, ifiler [,iradius, isr])",
        "body": "hrtfstat",
        "description": "Generates static 3d binaural audio for headphones using a Woodworth based spherical head model with improved low frequency phase accuracy."
    },
    "shaker": {
        "prefix": "shaker(kamp, kfreq, kbeans, kdamp, ktimes [, idecay])",
        "body": "shaker",
        "description": "Sounds like the shaking of a maraca or similar gourd instrument."
    },
    "vphaseseg": {
        "prefix": "vphaseseg(kphase, ioutab, ielems, itab1,idist1,itab2 [,idist2,itab3, ... ,idistN-1,itabN])",
        "body": "vphaseseg",
        "description": "Allows one-dimensional HVS (Hyper-Vectorial Synthesis)."
    },
    "chanctrl": {
        "prefix": "chanctrl(ichnl, ictlno [, ilow] [, ihigh])",
        "body": "chanctrl",
        "description": "Get the current value of a MIDI channel controller and optionally map it onto specified range."
    },
    "vmap": {
        "prefix": "vmap(ifn1, ifn2, ielements [,idstoffset, isrcoffset])",
        "body": "vmap",
        "description": "Maps elements from a vector onto another according to indexes."
    },
    "pvsarp": {
        "prefix": "pvsarp(fsigin, kbin, kdepth, kgain)",
        "body": "pvsarp",
        "description": "Arpeggiate the spectral components of a streaming pv signal."
    },
    "for": {
        "prefix": "for var in array-expr do",
        "body": "for",
        "description": "A syntactic looping construction."
    },
    "adsyn": {
        "prefix": "adsyn(kamod, kfmod, ksmod, ifilcod)",
        "body": "adsyn",
        "description": "Output is an additive set of individually controlled sinusoids, using an oscillator bank."
    },
    "pdclip": {
        "prefix": "pdclip(ain, kWidth, kCenter [, ibipolar [, ifullscale]])",
        "body": "pdclip",
        "description": "Performs linear clipping on an audio signal or a phasor."
    },
    "shiftin": {
        "prefix": "shiftin(asig)",
        "body": "shiftin",
        "description": "Shifts the contents of an audio variable into a 1-dimensional array."
    },
    "expsegba": {
        "prefix": "expsegba(ia, itim1, ib [, itim2] [, ic] [...])",
        "body": "expsegba",
        "description": "An exponential segment generator operating at a-rate with absolute times."
    },
    "exitnow": {
        "prefix": "exitnow([ivalue])",
        "body": "exitnow",
        "description": "Exit Csound as fast as possible, with no cleaning up."
    },
    "lowres": {
        "prefix": "lowres(asig, xcutoff, xresonance [, iskip])",
        "body": "lowres",
        "description": "Another resonant lowpass filter."
    },
    "outkc": {
        "prefix": "outkc(kchn, knum, kvalue, kmin, kmax)",
        "body": "outkc",
        "description": "Sends MIDI controller messages at k-rate."
    },
    "interleave": {
        "prefix": "interleave(kin1[], kin2[])",
        "body": "interleave",
        "description": "Interleaves arrays into a a single one by placing the input data in alternate positions."
    },
    "betarand": {
        "prefix": "betarand(krange, kalpha, kbeta)",
        "body": "betarand",
        "description": "Beta distribution random number generator (positive values only)."
    },
    "octmidi": {
        "prefix": "octmidi()",
        "body": "octmidi",
        "description": "Get the note number, in octave-point-decimal units, of the current MIDI event."
    },
    "opcodeinfo": {
        "prefix": "opcodeinfo({obj:Opcode, opc:OpcodeDef})",
        "body": "opcodeinfo",
        "description": "Prints information on an opcode definition and its overloads."
    },
    "randi": {
        "prefix": "randi({x, k}amp, xcps [, iseed] [, isize] [, ioffset])",
        "body": "randi",
        "description": "Generates a controlled random number series with interpolation between each new number."
    },
    "pvsmaska": {
        "prefix": "pvsmaska(fsrc, ifn, kdepth)",
        "body": "pvsmaska",
        "description": "Modify amplitudes using a function table, with dynamic scaling."
    },
    "lincos": {
        "prefix": "lincos({i, k}x, ky0, ky1 [, kx0, kx1 ])",
        "body": "lincos",
        "description": "Linear to cosine interpolation."
    },
    "sfplaym": {
        "prefix": "sfplaym(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])",
        "body": "sfplaym",
        "description": "Plays a SoundFont2 (SF2) sample preset, generating a mono sound."
    },
    "a": {
        "prefix": "a(k)",
        "body": "a",
        "description": "Converts a k-sig or k-array parameter to an a-sig output."
    },
    "bob": {
        "prefix": "bob(ain, xcf, xres, xsat [, iosamps, istor])",
        "body": "bob",
        "description": "Runge-Kutte numerical simulation of the Moog analog resonant filter."
    },
    "cntRead": {
        "prefix": "cntRead(icnt)",
        "body": "cntRead",
        "description": "Read current value of a counter object without changing it."
    },
    "dates": {
        "prefix": "dates([ itime])",
        "body": "dates",
        "description": "Returns as a string the date and time specified."
    },
    "pvsdiskin": {
        "prefix": "pvsdiskin(SFname, ktscal, kgain [, ioffset, ichan])",
        "body": "pvsdiskin",
        "description": "Create an fsig stream by reading a selected channel from a PVOC-EX analysis file, with frame interpolation."
    },
    "outq3": {
        "prefix": "outq3(asig)",
        "body": "outq3",
        "description": "Writes samples to quad channel 3 of an external device or stream."
    },
    "ctrlselect": {
        "prefix": "ctrlselect(kpre)",
        "body": "ctrlselect",
        "description": "Loads a preset of values for MIDI controllers from a previous ctrlpreset call."
    },
    "table": {
        "prefix": "table({a, i, k}ndx, ifn [, ixmode] [, ixoff] [, iwrap])",
        "body": "table",
        "description": "Accesses table values by direct indexing."
    },
    "tablemix": {
        "prefix": "tablemix(kdft, kdoff, klen, ks1ft, ks1off, ks1g, ks2ft, ks2off, ks2g)",
        "body": "tablemix",
        "description": "Mixes two tables."
    },
    "veloc": {
        "prefix": "veloc([ilow] [, ihigh])",
        "body": "veloc",
        "description": "Get the velocity from a MIDI event."
    },
    "arg": {
        "prefix": "arg(var:Complex)",
        "body": "arg",
        "description": "Returns the argument of a complex number."
    },
    "minabs": {
        "prefix": "minabs({a, k}in1, ain2 [, ain3] [, ain4] [...])",
        "body": "minabs",
        "description": "Produces a signal that is the minimum of the absolute values of any number of input signals."
    },
    "pitch": {
        "prefix": "pitch(asig, iupdte, ilo, ihi, idbthresh [, ifrqs] [, iconf] [, istrt] [, iocts] [, iq] [, inptls] [, irolloff] [, iskip])",
        "body": "pitch",
        "description": "Tracks the pitch of a signal."
    },
    "moogladder": {
        "prefix": "moogladder(ain, kcf, kre [, istor])",
        "body": "moogladder",
        "description": "Moog ladder lowpass filter."
    },
    "minabsaccum": {
        "prefix": "minabsaccum(aAccumulator, aInput)",
        "body": "minabsaccum",
        "description": "Accumulates the minimum of the absolute values of audio signals."
    },
    "vbap16": {
        "prefix": "vbap16(asig, kazim [, kelev] [, kspread])",
        "body": "vbap16",
        "description": "Distributes an audio signal among 16 channels."
    },
    "vbap8": {
        "prefix": "vbap8(asig, kazim [, kelev] [, kspread])",
        "body": "vbap8",
        "description": "Distributes an audio signal among 8 channels."
    },
    "maxalloc": {
        "prefix": "maxalloc({i, S}nsnum, icount)",
        "body": "maxalloc",
        "description": "Limits the number of allocations of an instrument."
    },
    "wrap": {
        "prefix": "wrap({a, i, k}sig, klow, khigh)",
        "body": "wrap",
        "description": "Wraps-around the signal that exceeds the low and high thresholds."
    },
    "cps2pch": {
        "prefix": "cps2pch(ipch, iequal)",
        "body": "cps2pch",
        "description": "Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of the octave."
    },
    "reshapearray": {
        "prefix": "reshapearray(array[], isize0 [, isize1 ])",
        "body": "reshapearray",
        "description": "Reshape an array, maintaining its capacity."
    },
    "tonex": {
        "prefix": "tonex(asig, khp [, inumlayer] [, iskip])",
        "body": "tonex",
        "description": "Emulates a stack of filters using the tone opcode."
    },
    "loscilx": {
        "prefix": "loscilx(xamp, kcps, ifn [, iwsize, ibas, istrt, imod, ibeg, iend])",
        "body": "loscilx",
        "description": "Read sampled sound (up to 16 channels) from a table, with optional sustain and release looping."
    },
    "fmax": {
        "prefix": "fmax({i, k}arg1[], iarg2[])",
        "body": "fmax",
        "description": "Returns the maximum of its two arguments."
    },
    "linrand": {
        "prefix": "linrand(krange)",
        "body": "linrand",
        "description": "Linear distribution random number generator (positive values only)."
    },
    "rspline": {
        "prefix": "rspline({x, k}rangeMin, xrangeMax, kcpsMin, kcpsMax)",
        "body": "rspline",
        "description": "Generate random spline curves."
    },
    "spat3d": {
        "prefix": "spat3d(ain, kX, kY, kZ, idist, ift, imode, imdel, iovr [, istor])",
        "body": "spat3d",
        "description": "Positions the input sound in a 3D space and allows moving the sound at k-rate."
    },
    "prints": {
        "prefix": "prints(\"string\" [, xval1] [, xval2] [...])",
        "body": "prints",
        "description": "Prints at init-time using a printf() style syntax."
    },
    "ms2st": {
        "prefix": "ms2st(am, as, kwidth)",
        "body": "ms2st",
        "description": "Mid-Side to stereo Conversion with a width control."
    },
    "setksmps": {
        "prefix": "setksmps(iksmps)",
        "body": "setksmps",
        "description": "Sets the local ksmps value in an instrument or user-defined opcode block."
    },
    "hilbert2": {
        "prefix": "hilbert2(sig:a, fftsize:a, hopsize:i)",
        "body": "hilbert2",
        "description": "A DFT-based implementation of a Hilbert transformer."
    },
    "octpch": {
        "prefix": "octpch(pch)",
        "body": "octpch",
        "description": "Converts a pitch-class value to octave-point-decimal."
    },
    "table3": {
        "prefix": "table3({a, i, k}ndx, ifn [, ixmode] [, ixoff] [, iwrap])",
        "body": "table3",
        "description": "Accesses table values by direct indexing with cubic interpolation."
    },
    "outic": {
        "prefix": "outic(ichn, inum, ivalue, imin, imax)",
        "body": "outic",
        "description": "Sends MIDI controller output at i-rate."
    },
    "sinh": {
        "prefix": "sinh(x)",
        "body": "sinh",
        "description": "Returns the hyperbolic sine of _x_ (_x_ in radians)."
    },
    "jitter2": {
        "prefix": "jitter2(ktotamp, kamp1, kcps1, kamp2, kcps2, kamp3, kcps3[ , iopt])",
        "body": "jitter2",
        "description": "Generates a segmented line with user-controllable random segments."
    },
    "timeinstk": {
        "prefix": "timeinstk()",
        "body": "timeinstk",
        "description": "Read absolute time in k-rate cycles, since the start of aninstance of an instrument."
    },
    "mandel": {
        "prefix": "mandel(trig, kx, ky, kmaxIter)",
        "body": "mandel",
        "description": "Mandelbrot set."
    },
    "unirand": {
        "prefix": "unirand(krange)",
        "body": "unirand",
        "description": "Uniform distribution random number generator (positive values only)."
    },
    "pdhalfy": {
        "prefix": "pdhalfy(ain, kShapeAmount [, ibipolar [, ifullscale]])",
        "body": "pdhalfy",
        "description": "Distorts a phasor for reading two unequal portions of a table in equal periods."
    },
    "cpsmidi": {
        "prefix": "cpsmidi()",
        "body": "cpsmidi",
        "description": "Get the note number of the current MIDI event, expressed in cycles-per-second."
    },
    "fmb3": {
        "prefix": "fmb3(kamp, kfreq, kc1, kc2, kvdepth, kvrat [, ifn1, ifn2, ifn3, ifn4, ivfn])",
        "body": "fmb3",
        "description": "Uses FM synthesis to create a Hammond B3 organ sound."
    },
    "|": {
        "prefix": "a | b  (bitwise OR)",
        "body": "|",
        "description": "Bitwise OR operator."
    },
    "array": {
        "prefix": "array(arg:a)",
        "body": "array",
        "description": "Converts an input into an array, optionally creating it."
    },
    "tlineto": {
        "prefix": "tlineto(ksig, ktime, ktrig)",
        "body": "tlineto",
        "description": "Generate glissandos starting from a control signal with a trigger."
    },
    "cpstun": {
        "prefix": "cpstun(ktrig, kindex, kfn)",
        "body": "cpstun",
        "description": "Returns micro-tuning values at k-rate."
    },
    "cpsoct": {
        "prefix": "cpsoct(oct)",
        "body": "cpsoct",
        "description": "Converts an octave-point-decimal value to cycles-per-second."
    },
    "rms": {
        "prefix": "rms(asig [, ihp] [, iskip])",
        "body": "rms",
        "description": "Determines the root-mean-square amplitude of an audio signal."
    },
    "midifilein": {
        "prefix": "midifilein({index:k, [id:k], index:i, [id:i]})",
        "body": "midifilein",
        "description": "Returns a generic MIDI message from a MIDI file."
    },
    "s32b14": {
        "prefix": "s32b14(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, initvalue1, ifn1, ..., ictlno_msb32, ictlno_lsb32, imin32, imax32, initvalue32, ifn32)",
        "body": "s32b14",
        "description": "Creates a bank of 32 different 14-bit MIDI control message numbers."
    },
    "pcount": {
        "prefix": "pcount()",
        "body": "pcount",
        "description": "Returns the number of pfields belonging to a note event."
    },
    "fink": {
        "prefix": "fink(ifilename, iskipframes, iformat, kin1 [, kin2] [, kin3] [,...])",
        "body": "fink",
        "description": "Read signals from a file at k-rate."
    },
    "getftargs": {
        "prefix": "getftargs(iftno, ktrig)",
        "body": "getftargs",
        "description": "Fill a string variable with the arguments used to create a function table at k-rate."
    },
    "rigoto": {
        "prefix": "rigoto(label)",
        "body": "rigoto",
        "description": "Transfers control during a reinit pass."
    },
    "urandom": {
        "prefix": "urandom([imin, imax])",
        "body": "urandom",
        "description": "Truly random opcodes with controllable range."
    },
    "sfinstr3": {
        "prefix": "sfinstr3(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle [, iflag] [, ioffset])",
        "body": "sfinstr3",
        "description": "Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound with cubic interpolation."
    },
    "trandom": {
        "prefix": "trandom(ktrig, kmin, kmax)",
        "body": "trandom",
        "description": "Generates a controlled pseudo-random number series between min and max values at k-rate whenever the trigger parameter is different to 0."
    },
    "partikkel": {
        "prefix": "partikkel(agrainfreq, kdistribution, idisttab, async, kenv2amt, ienv2tab, ienv_attack, ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, ifmamptab, kfmenv, icosine, ktraincps, knumpartials, kchroma, ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, kwaveform4, iwaveamptab, asamplepos1, asamplepos2, asamplepos3, asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains [, iopcode_id, ipanlaws])",
        "body": "partikkel",
        "description": "Granular synthesizer with &quot;per grain&quot; control over many of its parameters.  Has a sync input to sychronize its internal grain scheduler clock to an external clock source."
    },
    "noteon": {
        "prefix": "noteon(ichn, inum, ivel)",
        "body": "noteon",
        "description": "Send a noteon message to the MIDI OUT port."
    },
    "clip": {
        "prefix": "clip(asig, imeth, ilimit [, iarg])",
        "body": "clip",
        "description": "Clips an a-rate signal to a predefined limit, in a &amp;#8220;soft&amp;#8221; manner, using one of three methods."
    },
    "\\#": {
        "prefix": "a # b  (bitwise NON EQUIVALENCE)",
        "body": "\\#",
        "description": "Bitwise NON EQUIVALENCE operator."
    },
    "timeinsts": {
        "prefix": "timeinsts()",
        "body": "timeinsts",
        "description": "Read absolute time, in seconds, since the start of an instance of an instrument."
    },
    "noteondur2": {
        "prefix": "noteondur2(ichn, inum, ivel, idur)",
        "body": "noteondur2",
        "description": "Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity."
    },
    "cngoto": {
        "prefix": "cngoto(condition, label)",
        "body": "cngoto",
        "description": "Transfers control on every pass when the condition is _not_ true."
    },
    "midiarp": {
        "prefix": "midiarp(kRat [, kMode])",
        "body": "midiarp",
        "description": "Generates arpeggios based on currently held MIDI notes."
    },
    "outq": {
        "prefix": "outq(asig1, asig2, asig3, asig4)",
        "body": "outq",
        "description": "Writes 4-channel audio data to an external device or stream."
    },
    "maparray": {
        "prefix": "maparray(kinarray, String)",
        "body": "maparray",
        "description": "Apply a function of one argument to every element of a vector (one-dimensional k-rate array)."
    },
    "vbap4move": {
        "prefix": "vbap4move(asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...])",
        "body": "vbap4move",
        "description": "Distributes an audio signal among 4 channels with moving virtual sources."
    },
    "trigphasor": {
        "prefix": "trigphasor(xtrig, xrate, kstart, kend [, kresetPos])",
        "body": "trigphasor",
        "description": "A resettable linear ramp between two levels."
    },
    "insglobal": {
        "prefix": "insglobal(isource, instrnum [,instrnum...])",
        "body": "insglobal",
        "description": "An opcode which can be used to implement a remote orchestra. This opcode will send note events from a source machine to many destinations."
    },
    "undersample": {
        "prefix": "undersample(ifactor [,icvt_in, icvt_out])",
        "body": "undersample",
        "description": "Sets a lower local sampling rate based on an undersampling factor."
    },
    "passign": {
        "prefix": "passign([istart [, iend])",
        "body": "passign",
        "description": "Assigns a range of p-fields to ivariables, or i- or k-array."
    },
    "s16b14": {
        "prefix": "s16b14(ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, initvalue1, ifn1, ..., ictlno_msb16, ictlno_lsb16, imin16, imax16, initvalue16, ifn16)",
        "body": "s16b14",
        "description": "Creates a bank of 16 different 14-bit MIDI control message numbers."
    },
    "plltrack": {
        "prefix": "plltrack(asig, kd [, kloopf, kloopq, klf, khf, kthresh])",
        "body": "plltrack",
        "description": "Tracks the pitch of a signal."
    },
    "fouti": {
        "prefix": "fouti(ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN])",
        "body": "fouti",
        "description": "Outputs i-rate signals of an arbitrary number of channels to a specified file."
    },
    "cosh": {
        "prefix": "cosh(x)",
        "body": "cosh",
        "description": "Returns the hyperbolic cosine of _x_ (_x_ in radians)."
    },
    "midinoteoff": {
        "prefix": "midinoteoff(xkey, xvelocity)",
        "body": "midinoteoff",
        "description": "Gets a MIDI noteoff value."
    },
    "minaccum": {
        "prefix": "minaccum(aAccumulator, aInput)",
        "body": "minaccum",
        "description": "Accumulates the minimum value of audio signals."
    },
    "paulstretch": {
        "prefix": "paulstretch(istretch, iwindowsize, ift)",
        "body": "paulstretch",
        "description": "Extreme time-stretching algorithm by Nasca Octavian Paul."
    },
    "cntCreate": {
        "prefix": "cntCreate([imax, imin, inc])",
        "body": "cntCreate",
        "description": "Create a counter object."
    },
    "outletkid": {
        "prefix": "outletkid(Sname, SinstanceID, ksignal)",
        "body": "outletkid",
        "description": "Sends a krate signal out from an instrument to a named port."
    },
    "hrtfmove": {
        "prefix": "hrtfmove(asrc, kAz, kElev, ifilel, ifiler [, imode, ifade, isr])",
        "body": "hrtfmove",
        "description": "Generates dynamic 3d binaural audio for headphones using magnitude interpolation and phase truncation."
    },
    "lag": {
        "prefix": "lag({a, k}in, klagtime [, initialvalue])",
        "body": "lag",
        "description": "Exponential Lag."
    },
    "tab": {
        "prefix": "tab({x, k}ndx, if [, ixmode])",
        "body": "tab",
        "description": "Fast table opcode."
    },
    "slider8table": {
        "prefix": "slider8table(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, ..., ictlnum8, imin8, imax8, init8, ifn8)",
        "body": "slider8table",
        "description": "Stores a bank of 8 different MIDI control messages to a table."
    },
    "\u02c6": {
        "prefix": "a ^ b  (b not audio-rate)",
        "body": "\u02c6",
        "description": "&amp;#8220;Power of&amp;#8221; operator."
    },
    "printk": {
        "prefix": "printk(itime, kval [, ispace] [, inamed])",
        "body": "printk",
        "description": "Prints one k-rate value at specified intervals."
    },
    "pvsifd": {
        "prefix": "pvsifd(ain, ifftsize, ihopsize, iwintype [,iscal])",
        "body": "pvsifd",
        "description": "Instantaneous Frequency Distribution, magnitude and phase analysis."
    },
    "vlowres": {
        "prefix": "vlowres(asig, kfco, kres, iord, ksep)",
        "body": "vlowres",
        "description": "A bank of filters in which the cutoff frequency can be separated under user control."
    },
    "reverb": {
        "prefix": "reverb(asig, krvt [, iskip])",
        "body": "reverb",
        "description": "Reverberates an input signal with a &amp;#8220;natural room&amp;#8221; frequency response."
    },
    "init": {
        "prefix": "init({size1: [, size2:i, ...], a, op:Opcod [, arg1:*, ...], inst:Inst [, p4:i, ...]})",
        "body": "init",
        "description": "Initialises one or more objects."
    },
    "vbap8move": {
        "prefix": "vbap8move(asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...])",
        "body": "vbap8move",
        "description": "Distributes an audio signal among 8 channels with moving virtual sources."
    },
    "cuserrnd": {
        "prefix": "cuserrnd({i, k}min, kmax, ktableNum)",
        "body": "cuserrnd",
        "description": "Continuous USER-defined-distribution RaNDom generator."
    },
    "eventtime": {
        "prefix": "eventtime()",
        "body": "eventtime",
        "description": "Read absolute time, in seconds, since the start of an instance of an instrument."
    },
    "compileorc": {
        "prefix": "compileorc(Sfilename)",
        "body": "compileorc",
        "description": "Compiles a new orchestra from an ASCII file."
    },
    "printsk": {
        "prefix": "printsk(\"string\" [, xval1] [, xval2] [...])",
        "body": "printsk",
        "description": "Prints at k-rate using a printf() style syntax."
    },
    "pvswarp": {
        "prefix": "pvswarp(fsigin, kscal, kshift [, klowest, kmeth, kgain, kcoefs])",
        "body": "pvswarp",
        "description": "Warp the spectral envelope of a PVS signal by means of shifting and scaling."
    },
    "midinoteonoct": {
        "prefix": "midinoteonoct(xoct, xvelocity)",
        "body": "midinoteonoct",
        "description": "Gets a MIDI note number value as octave-point-decimal value."
    },
    "tradsyn": {
        "prefix": "tradsyn(fin, kscal, kpitch, kmaxtracks, ifn)",
        "body": "tradsyn",
        "description": "Streaming partial track additive synthesis."
    },
    "outletk": {
        "prefix": "outletk(Sname, ksignal)",
        "body": "outletk",
        "description": "Sends a krate signal out from an instrument to a named port."
    },
    "nrpn": {
        "prefix": "nrpn(kchan, kparmnum, kparmvalue)",
        "body": "nrpn",
        "description": "Sends a NPRN (Non-Registered Parameter Number) message to the MIDI OUT port each time one of the input arguments changes."
    },
    "pvstrace": {
        "prefix": "pvstrace(fsigin, kn)",
        "body": "pvstrace",
        "description": "Process a PV stream by retaining only the N bins with the highest amplitude, zeroing the others."
    },
    "fmod": {
        "prefix": "fmod({i, k}arg1[], iarg2[])",
        "body": "fmod",
        "description": "Computes the remainder of the division of its first argument by the second."
    },
    "trigseq": {
        "prefix": "trigseq(ktrig_in, kstart, kloop, kinitndx, kfn_values, kout1 [, kout2] [...])",
        "body": "trigseq",
        "description": "Accepts a trigger signal as input and outputs a group of values."
    },
    "nstrstr": {
        "prefix": "nstrstr({i, k}nsno)",
        "body": "nstrstr",
        "description": "Returns the string of a named instr from its number or an empty string if no such association exists."
    },
    "resonz": {
        "prefix": "resonz(asig, xcf, xbw [, iscl] [, iskip])",
        "body": "resonz",
        "description": "A second-order, two-pole two-zero bandpass filter with variable frequency response."
    },
    "cntState": {
        "prefix": "cntState(icnt)",
        "body": "cntState",
        "description": "Gives the range and increment of a counter."
    },
    "sfinstr3m": {
        "prefix": "sfinstr3m(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle [, iflag] [, ioffset])",
        "body": "sfinstr3m",
        "description": "Plays a SoundFont2 (SF2) sample instrument, generating a mono sound with cubic interpolation."
    },
    "pvsbuffer": {
        "prefix": "pvsbuffer(fsig, ilen)",
        "body": "pvsbuffer",
        "description": "This opcode creates and writes to a circular buffer for f-signals (streaming PV signals)."
    },
    "weibull": {
        "prefix": "weibull(ksigma, ktau)",
        "body": "weibull",
        "description": "Weibull distribution random number generator (positive values only)."
    },
    "delayw": {
        "prefix": "delayw(asig)",
        "body": "delayw",
        "description": "Writes the audio signal to a digital delay line."
    },
    "linlin": {
        "prefix": "linlin({i, k}x, ky0, ky1 [, kx0, kx1 ])",
        "body": "linlin",
        "description": "Linear to linear interpolation."
    },
    "nsamp": {
        "prefix": "nsamp(x)",
        "body": "nsamp",
        "description": "Returns the number of samples loaded into a stored function table number."
    },
    "ATSsinnoi": {
        "prefix": "ATSsinnoi(ktimepnt, ksinlev, knzlev, kfmod, iatsfile, ipartials [, ipartialoffset, ipartialincr])",
        "body": "ATSsinnoi",
        "description": "_ATSsinnoi_ reads data from an ATS data file and uses the information to synthesize sines and noise together."
    },
    "wgpluck": {
        "prefix": "wgpluck(icps, iamp, kpick, iplk, idamp, ifilt, axcite)",
        "body": "wgpluck",
        "description": "A high fidelity simulation of a plucked string, using interpolating delay-lines."
    },
    "liveconv": {
        "prefix": "liveconv(ain, ift, iplen, kupdate, kclear)",
        "body": "liveconv",
        "description": "Partitioned convolution with dynamically reloadable impulse response."
    },
    "fmmetal": {
        "prefix": "fmmetal(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn)",
        "body": "fmmetal",
        "description": "Uses FM synthesis to create a &amp;#8220;Heavy Metal&amp;#8221; sound."
    },
    "tabw": {
        "prefix": "tabw({a, k}sig, kndx, ifn [,ixmode])",
        "body": "tabw",
        "description": "Fast table opcodes."
    },
    "pchmidinn": {
        "prefix": "pchmidinn(MidiNoteNumber)",
        "body": "pchmidinn",
        "description": "Converts a Midi note number value to octave point pitch-class units."
    },
    "sfinstr": {
        "prefix": "sfinstr(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle [, iflag] [, ioffset])",
        "body": "sfinstr",
        "description": "Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound."
    },
    "bbcuts": {
        "prefix": "bbcuts(asource1, asource2, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats [, istutterspeed] [, istutterchance] [, ienvchoice])",
        "body": "bbcuts",
        "description": "Generates breakbeat-style cut-ups of a stereo audio stream."
    },
    "expsegb": {
        "prefix": "expsegb(ia, itim1, ib [, itim2] [, ic] [...])",
        "body": "expsegb",
        "description": "Trace a series of exponential segments between specified absolute points."
    },
    "diskin2": {
        "prefix": "diskin2(ifilco [, kpitc [, iskiptim [, iwra [, iforma [, iwsiz [, ibufsiz [, iskipinit]]]]]]])",
        "body": "diskin2",
        "description": "Reads audio data from a file, and can alter its pitch using one of several available interpolation types, as well as convert the sample rate to match the orchestra sr setting."
    },
    "zacl": {
        "prefix": "zacl(kfirst [, klast])",
        "body": "zacl",
        "description": "Clears one or more variables in the za space."
    },
    "midichn": {
        "prefix": "midichn()",
        "body": "midichn",
        "description": "Returns the MIDI channel number (1 - 16) from which the note was activated."
    },
    "monitor": {
        "prefix": "monitor()",
        "body": "monitor",
        "description": "Returns the audio spout frame (if active), otherwise it returns zero."
    },
    "setcol": {
        "prefix": "setcol(i/kin[], i/kcol)",
        "body": "setcol",
        "description": "Sets a given column of a 2-dimensional array from a vector."
    },
    "ATSinfo": {
        "prefix": "ATSinfo(iatsfile, ilocation)",
        "body": "ATSinfo",
        "description": "Reads data out of the header of an ATS file."
    },
    "midipolyaftertouch": {
        "prefix": "midipolyaftertouch(xpolyaftertouch, xkey [, ilow] [, ihigh])",
        "body": "midipolyaftertouch",
        "description": "Gets a MIDI polyphonic aftertouch value."
    },
    "spechist": {
        "prefix": "spechist(wsigin)",
        "body": "spechist",
        "description": "Accumulates the values of successive spectral frames."
    },
    "vdelayk": {
        "prefix": "vdelayk(ksig, kdel, imaxdel [, iskip, imode])",
        "body": "vdelayk",
        "description": "Variable time delay applied to a k-rate signal."
    },
    "copya2ftab": {
        "prefix": "copya2ftab({i, k}Array[], ktab [, koffset])",
        "body": "copya2ftab",
        "description": "The _copya2ftab_ opcode takes a k-array and copies the contents to an f-table."
    },
    "locsend": {
        "prefix": "locsend()",
        "body": "locsend",
        "description": "Distributes the audio signals of a previous [locsig] opcode."
    },
    "vdelay": {
        "prefix": "vdelay(asig, adel, imaxdel [, iskip])",
        "body": "vdelay",
        "description": "An interpolating variable time delay."
    },
    "strtolk": {
        "prefix": "strtolk({k, S}str)",
        "body": "strtolk",
        "description": "Converts a string to a signed integer value at i- or k-rate."
    },
    "schedkwhennamed": {
        "prefix": "schedkwhennamed(ktrigger, kmintim, kmaxnum, \"name\", kwhen, kdur [, ip4] [, ip5] [...])",
        "body": "schedkwhennamed",
        "description": "Similar to [schedkwhen] but uses a named instrument at init-time."
    },
    "adsynt2": {
        "prefix": "adsynt2(kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs])",
        "body": "adsynt2",
        "description": "Performs additive synthesis with an arbitrary number of partials, not necessarily harmonic. (see [adsynt] for detailed manual)"
    },
    "midinoteonkey": {
        "prefix": "midinoteonkey(xkey, xvelocity)",
        "body": "midinoteonkey",
        "description": "Gets a MIDI note number value."
    },
    "phs": {
        "prefix": "phs(kin[])",
        "body": "phs",
        "description": "Obtains the phases of a complex-number array."
    },
    "cggoto": {
        "prefix": "cggoto(condition, label)",
        "body": "cggoto",
        "description": "Conditionally transfer control to _label_ on every pass. (Combination of [cigoto])"
    },
    "metrobpm": {
        "prefix": "metrobpm(freq [, initphase] [, kgate])",
        "body": "metrobpm",
        "description": "Trigger Metronome with optional gate."
    },
    "pvsout": {
        "prefix": "pvsout(fsig, kchan)",
        "body": "pvsout",
        "description": "Write a fsig to the pvs output bus."
    },
    "vbapmove": {
        "prefix": "vbapmove(asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...])",
        "body": "vbapmove",
        "description": "Distributes an audio signal among upto 64 channels with moving virtual sources."
    },
    "tab_i": {
        "prefix": "tab_i(indx, if [, ixmode])",
        "body": "tab_i",
        "description": "Fast table opcodes."
    },
    "semitone": {
        "prefix": "semitone(x)",
        "body": "semitone",
        "description": "Calculates a factor to raise/lower a frequency by a given amount of semitones."
    },
    "tanh": {
        "prefix": "tanh(x)",
        "body": "tanh",
        "description": "Returns the hyperbolic tangent of _x_."
    },
    "partikkelsync": {
        "prefix": "partikkelsync(iopcode_id)",
        "body": "partikkelsync",
        "description": "Outputs _partikkel_&#x27;s grain scheduler clock pulse and phase to synchronize several instances of the _partikkel_ opcode to the same clock source."
    },
    "expon": {
        "prefix": "expon(ia, idur, ib)",
        "body": "expon",
        "description": "Trace an exponential curve between specified points."
    },
    "ntof": {
        "prefix": "ntof(Snote)",
        "body": "ntof",
        "description": "Convert note name to frequency."
    },
    "vbap": {
        "prefix": "vbap(asig, kazim [,kelev] [, kspread] [, ilayout])",
        "body": "vbap",
        "description": "Distributes an audio signal among many channels, up to 64 in the first form, arbitrary in the second."
    },
    "specsum": {
        "prefix": "specsum(wsig [, interp])",
        "body": "specsum",
        "description": "Sums the magnitudes across all channels of the spectrum."
    },
    "ftsave": {
        "prefix": "ftsave(\"filename\", iflag, ifn1 [, ifn2] [...])",
        "body": "ftsave",
        "description": "Save a set of previously-allocated tables to a file."
    },
    "filesr": {
        "prefix": "filesr(ifilcod [, iallowraw])",
        "body": "filesr",
        "description": "Returns the sample rate of a sound file."
    },
    "randomh": {
        "prefix": "randomh(kmin, kmax, xcps [,imode] [,ifirstval])",
        "body": "randomh",
        "description": "Generates random numbers with a user-defined limit and holds them for a period of time."
    },
    "pvscross": {
        "prefix": "pvscross(fsrc, fdest, kamp1, kamp2)",
        "body": "pvscross",
        "description": "Performs cross-synthesis between two source fsigs."
    },
    "expcurve": {
        "prefix": "expcurve(kindex, ksteepness)",
        "body": "expcurve",
        "description": "Generates a normalised exponential curve in range 0 to 1 of arbitrary steepness."
    },
    "vpow_i": {
        "prefix": "vpow_i(ifn, ival, ielements [, idstoffset])",
        "body": "vpow_i",
        "description": "Raises each element of a vector to a scalar power."
    },
    "vpowv_i": {
        "prefix": "vpowv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vpowv_i",
        "description": "Performs power-of operations between two vectorial control signals at init time."
    },
    "vexp_i": {
        "prefix": "vexp_i(ifn, ival, ielements [, idstoffset])",
        "body": "vexp_i",
        "description": "Performs power-of operations between a vector and a scalar."
    },
    "compress2": {
        "prefix": "compress2(aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook)",
        "body": "compress2",
        "description": "Compress, limit, expand, duck or gate an audio signal."
    },
    "push_f": {
        "prefix": "push_f(fsig)",
        "body": "push_f",
        "description": "Pushes an f-sig frame into the global stack.  Deprecated."
    },
    "midictrl": {
        "prefix": "midictrl(inum [, imin] [, imax])",
        "body": "midictrl",
        "description": "Get the current value (0-127) of a specified MIDI controller."
    },
    "ckgoto": {
        "prefix": "ckgoto(condition, label)",
        "body": "ckgoto",
        "description": "During the p-time passes only, conditionally transfer control to the statement labeled by _label_."
    },
    "foscil": {
        "prefix": "foscil(xamp, kcps, xcar, xmod, kndx [, ifn , iphs])",
        "body": "foscil",
        "description": "A basic frequency modulated oscillator."
    },
    "maxaccum": {
        "prefix": "maxaccum(aAccumulator, aInput)",
        "body": "maxaccum",
        "description": "Accumulates the maximum value of audio signals."
    },
    "partikkelget": {
        "prefix": "partikkelget(kparameterindex, iopcode_id)",
        "body": "partikkelget",
        "description": "Get mask index for a specific mask parameter of a running _partikkel_ instance."
    },
    "oscilx": {
        "prefix": "oscilx(kamp, ifrq, ifn, itimes)",
        "body": "oscilx",
        "description": "Accesses table values at a user-defined frequency."
    },
    "release": {
        "prefix": "release()",
        "body": "release",
        "description": "Indicates whether a note is in its _release_ stage."
    },
    "mirror": {
        "prefix": "mirror({a, i, k}sig, klow, khigh)",
        "body": "mirror",
        "description": "Reflects the signal that exceeds the low and high thresholds."
    },
    "vlinseg": {
        "prefix": "vlinseg(ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]])",
        "body": "vlinseg",
        "description": "Vectorial envelope generator. Generate linear vectorial segments."
    },
    "vmultv": {
        "prefix": "vmultv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vmultv",
        "description": "Performs mutiplication between two vectorial control signals."
    },
    "vosim": {
        "prefix": "vosim(kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip])",
        "body": "vosim",
        "description": "Simple vocal simulation based on glottal pulses with formant characteristics."
    },
    "evalstr": {
        "prefix": "evalstr(Scode)",
        "body": "evalstr",
        "description": "Evaluates a string containing Csound code, returning a value from the global space (instr 0)."
    },
    "puts": {
        "prefix": "puts(Sstr, ktrig [, inonl])",
        "body": "puts",
        "description": "Print a string with an optional newline at the end whenever the trigger signal is positive and changes."
    },
    "flanger": {
        "prefix": "flanger(asig, adel, kfeedback [, imaxd])",
        "body": "flanger",
        "description": "A user controlled flanger."
    },
    "scoreline_i": {
        "prefix": "scoreline_i(Sin)",
        "body": "scoreline_i",
        "description": "Issues one or more score line events from an instrument at i-time."
    },
    "strupper": {
        "prefix": "strupper(Ssrc)",
        "body": "strupper",
        "description": "Convert Ssrc to upper case, and write the result to Sdst."
    },
    "samphold": {
        "prefix": "samphold({a, k}sig, agate [, ival] [, ivstor])",
        "body": "samphold",
        "description": "Performs a sample-and-hold operation on its input."
    },
    "pvsfilter": {
        "prefix": "pvsfilter(fsigin, fsigfil, kdepth [, igain])",
        "body": "pvsfilter",
        "description": "Multiply amplitudes of a pvoc stream by those of a second pvoc stream, with dynamic scaling."
    },
    "distort": {
        "prefix": "distort(asig, kdist, if [, ihp, istor])",
        "body": "distort",
        "description": "Distort an audio signal via waveshaping and optional clipping."
    },
    "ftslicei": {
        "prefix": "ftslicei(ifnsource, ifndest [, istart, iend, istep ])",
        "body": "ftslicei",
        "description": "Copy a slice from an f-table to another f-table at init."
    },
    "vaget": {
        "prefix": "vaget(kndx, avar)",
        "body": "vaget",
        "description": "Access values of the current buffer of an a-rate variable by indexing."
    },
    "strfromurl": {
        "prefix": "strfromurl(StringURL)",
        "body": "strfromurl",
        "description": "Set a string variable to the value found from reading an URL."
    },
    "log": {
        "prefix": "log({a,k,i,Complex})",
        "body": "log",
        "description": "Returns the natural log of _x_ (_x_ positive only)."
    },
    "ftslice": {
        "prefix": "ftslice({i, k}fnsource, ifndest [, kstart, kend, kstep ])",
        "body": "ftslice",
        "description": "Copy a slice from an f-table to another f-table at performance."
    },
    "compilecsd": {
        "prefix": "compilecsd(Sfilename)",
        "body": "compilecsd",
        "description": "Compiles a new orchestra from an ASCII file."
    },
    "dumpk4": {
        "prefix": "dumpk4(ksig1, ksig2, ksig3, ksig4, ifilname, iformat, iprd)",
        "body": "dumpk4",
        "description": "Periodically writes four orchestra control-signal values to a named external file in a specific format."
    },
    "reinit": {
        "prefix": "reinit(label)",
        "body": "reinit",
        "description": "Suspends a performance while a special initialization pass is executed."
    },
    "mvclpf3": {
        "prefix": "mvclpf3(ain, xcf, xre [, istor])",
        "body": "mvclpf3",
        "description": "Moog voltage-controlled lowpass filter emulation."
    },
    "moogladder2": {
        "prefix": "moogladder2(ain, kcf, kre [, istor])",
        "body": "moogladder2",
        "description": "Moog ladder lowpass filter."
    },
    "println": {
        "prefix": "println(\"string\" [, xval1] [, xval2] [...])",
        "body": "println",
        "description": "Prints at k-rate using a printf() style syntax like [printks], appends a new line."
    },
    "printks": {
        "prefix": "printks(\"string\", itime [, xval1] [, xval2] [...])",
        "body": "printks",
        "description": "Prints at k-rate using a printf() style syntax."
    },
    "OSCbundle": {
        "prefix": "OSCbundle(kwhen, ihost, iport, Sdest[], Stype[], kArgs[][] [, isize])",
        "body": "OSCbundle",
        "description": "Sends data to other processes using the OSC protocol by packing messages in a bundle."
    },
    "opcode": {
        "prefix": "opcode name, outtypes, intypes",
        "body": "opcode",
        "description": "Defines the start of user-defined opcode block."
    },
    "connect": {
        "prefix": "connect(Tsource1, Soutlet1, Tsink1, Sinlet1)",
        "body": "connect",
        "description": "Connects a source outlet to a sink inlet."
    },
    "ATScross": {
        "prefix": "ATScross(ktimepnt, kfmod, iatsfile, ifn, kmylev, kbuflev, ipartials [, ipartialoffset, ipartialincr])",
        "body": "ATScross",
        "description": "_ATScross_ uses data from an ATS analysis file and data from an [ATSbufread] to perform cross synthesis."
    },
    "ephasor": {
        "prefix": "ephasor(kfreq, kR)",
        "body": "ephasor",
        "description": "Produces two outputs: a periodic phase signal and a periodic exponential decaying signal."
    },
    "atonex": {
        "prefix": "atonex(asig, khp [, inumlayer] [, iskip])",
        "body": "atonex",
        "description": "Emulates a stack of filters using the atone opcode."
    },
    "mxadsr": {
        "prefix": "mxadsr(iatt, idec, islev, irel [, idel] [, ireltim])",
        "body": "mxadsr",
        "description": "Calculates the classical ADSR envelope using the [expsegr] mechanism."
    },
    "#ifdef": {
        "prefix": "#ifdef NAME",
        "body": "#ifdef",
        "description": "Conditional reading of code."
    },
    "cpsxpch": {
        "prefix": "cpsxpch(ipch, iequal, irepeat, ibase)",
        "body": "cpsxpch",
        "description": "Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of any interval."
    },
    "partials": {
        "prefix": "partials(ffr, fphs, kthresh, kminpts, kmaxgap, imaxtracks)",
        "body": "partials",
        "description": "Partial track spectral analysis."
    },
    "gausstrig": {
        "prefix": "gausstrig(kamp, kcps, kdev [, imode] [, ifrst1])",
        "body": "gausstrig",
        "description": "Random impulses around a certain frequency."
    },
    "setp": {
        "prefix": "setp(ins:Instr, num:k, val:k)",
        "body": "setp",
        "description": "Set the value of an instrument parameter."
    },
    "outrg": {
        "prefix": "outrg(kstart, aout1 [,aout2, aout3, ..., aoutN])",
        "body": "outrg",
        "description": "Outputs audio to a range of adjacent audio channels on the audio output device."
    },
    "pvsfreeze": {
        "prefix": "pvsfreeze(fsigin, kfreeza, kfreezf)",
        "body": "pvsfreeze",
        "description": "Freeze the amplitude and frequency time functions of a pv stream according to a control-rate trigger."
    },
    "dct": {
        "prefix": "dct({i, k}in[])",
        "body": "dct",
        "description": "Discrete Cosine Transform of a sample array (type-II DCT)."
    },
    "printks2": {
        "prefix": "printks2(\"string\", kval)",
        "body": "printks2",
        "description": "Prints a new value every time a control variable changes using a printf() style syntax."
    },
    "vcomb": {
        "prefix": "vcomb(asig, krvt, xlpt, imaxlpt [, iskip] [, insmps])",
        "body": "vcomb",
        "description": "Variably reverberates an input signal with a &amp;#8220;colored&amp;#8221; frequency response."
    },
    "chnparams": {
        "prefix": "chnparams(Sname)",
        "body": "chnparams",
        "description": "Query parameters of a channel (if it does not exist, all returned values are zero)."
    },
    "oscbnk": {
        "prefix": "oscbnk(kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, kl2minf, kl2maxf, ilfomode, keqminf, keqmaxf, keqminl, keqmaxl, keqminq, keqmaxq, ieqmode, kfn [, il1fn] [, il2fn] [, ieqffn] [, ieqlfn] [, ieqqfn] [, itabl] [, ioutfn])",
        "body": "oscbnk",
        "description": "Mixes the output of any number of oscillators."
    },
    "svn": {
        "prefix": "svn(asig, xcf, xQ, kdriv [, ifn,inm,imx, istor])",
        "body": "svn",
        "description": "Non-linear state variable filter."
    },
    "sqrt": {
        "prefix": "sqrt(x)",
        "body": "sqrt",
        "description": "Returns the square root of _x_ (_x_ non-negative)."
    },
    "oscil3": {
        "prefix": "oscil3({x, k}amp, xcps [, ifn, iphs])",
        "body": "oscil3",
        "description": "A simple oscillator with cubic interpolation."
    },
    "clear": {
        "prefix": "clear(avar1 [, avar2] [, avar3] [...])",
        "body": "clear",
        "description": "Zeroes a list of audio signals."
    },
    "sfilist": {
        "prefix": "sfilist(ifilhandle [, Sprintprefix])",
        "body": "sfilist",
        "description": "Prints a list of all instruments of a previously loaded SoundFont2 (SF2) sample file."
    },
    "ftexists": {
        "prefix": "ftexists({i, k}fn)",
        "body": "ftexists",
        "description": "Query if a given table exists."
    },
    "chnclear": {
        "prefix": "chnclear(Sname [, Sname2,...])",
        "body": "chnclear",
        "description": "Clears a number of audio output channel of the named software bus."
    },
    "loop_gt": {
        "prefix": "loop_gt({i, k}ndx, idecr, imin, label)",
        "body": "loop_gt",
        "description": "Construction of looping operations."
    },
    "pvscent": {
        "prefix": "pvscent(fsig)",
        "body": "pvscent",
        "description": "Calculate the spectral centroid of a signal from its discrete Fourier transform."
    },
    "serialPrint": {
        "prefix": "serialPrint(iPort)",
        "body": "serialPrint",
        "description": "Print data from a serial port."
    },
    "midiout": {
        "prefix": "midiout(kstatus, kchan, kdata1, kdata2)",
        "body": "midiout",
        "description": "Sends a generic MIDI message to the MIDI OUT port."
    },
    "serialEnd": {
        "prefix": "serialEnd(iPort)",
        "body": "serialEnd",
        "description": "Close a serial port for arduino."
    },
    "readk3": {
        "prefix": "readk3(ifilname, iformat, iprd)",
        "body": "readk3",
        "description": "Periodically reads three orchestra control-signal values from an external file."
    },
    "lenarray": {
        "prefix": "lenarray(karra [, iwhich])",
        "body": "lenarray",
        "description": "Evaluates the size or number of dimensions of an array."
    },
    "locsig": {
        "prefix": "locsig(asig, kdegree, kdistance, kreverbsend)",
        "body": "locsig",
        "description": "Takes an input signal and distributes between 2 or 4 channels."
    },
    "svfilter": {
        "prefix": "svfilter(asig, kcf, kq [, iscl] [, iskip])",
        "body": "svfilter",
        "description": "A resonant second order filter, with simultaneous lowpass, highpass and bandpass outputs."
    },
    "doppler": {
        "prefix": "doppler(asource, ksourceposition, kmicposition [, isoundspeed, ifiltercutoff])",
        "body": "doppler",
        "description": "A fast and robust method for approximating sound propagation, achieving convincing Doppler shifts without having to solve equations."
    },
    "nlfilt": {
        "prefix": "nlfilt(ain, ka, kb, kd, kC, kL)",
        "body": "nlfilt",
        "description": "A filter with a non-linear effect."
    },
    "follow": {
        "prefix": "follow(asig, idt)",
        "body": "follow",
        "description": "Envelope follower unit generator."
    },
    "linseg": {
        "prefix": "linseg(ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "linseg",
        "description": "Trace a series of line segments between specified points."
    },
    "fprints": {
        "prefix": "fprints(\"filename\", \"string\" [, ival1] [, ival2] [...])",
        "body": "fprints",
        "description": "Similar to [prints] but prints to a file."
    },
    "sekere": {
        "prefix": "sekere(iamp, idettack [, inum] [, idamp] [, imaxshake])",
        "body": "sekere",
        "description": "Semi-physical model of a sekere sound."
    },
    "follow2": {
        "prefix": "follow2(asig, katt, krel)",
        "body": "follow2",
        "description": "Another controllable envelope extractor using the algorithm attributed to Jean-Marc Jot."
    },
    "vmirror": {
        "prefix": "vmirror(ifn, kmin, kmax, ielements)",
        "body": "vmirror",
        "description": "&#x27;Reflects&#x27; elements of vectorial control signals on thresholds."
    },
    "<<": {
        "prefix": "a << b  (bitshift left)",
        "body": "<<",
        "description": "Bitshift left operator."
    },
    "rndseed": {
        "prefix": "rndseed(ival)",
        "body": "rndseed",
        "description": "Sets the global seed value for [rnd]."
    },
    "vtabwi": {
        "prefix": "vtabwi(indx, ifn, inarg1 [, inarg2, inarg3 , .... , inargN ])",
        "body": "vtabwi",
        "description": "Write vectors (to tables -or arrays of vectors) at init time."
    },
    "delayk": {
        "prefix": "delayk(ksig, ide [, imode])",
        "body": "delayk",
        "description": "Delays an input signal by some time interval."
    },
    "goto": {
        "prefix": "goto(label)",
        "body": "goto",
        "description": "Transfer control to _label_ on every pass. (Combination of [igoto])"
    },
    "cepsinv": {
        "prefix": "cepsinv(keps[])",
        "body": "cepsinv",
        "description": "Calculate the inverse cepstrum of an array."
    },
    "remoteport": {
        "prefix": "remoteport(iportnum)",
        "body": "remoteport",
        "description": "Defines the port for use with the _insremot_, _midremot_, _insglobal_ and _midglobal_ opcodes."
    },
    "hypot": {
        "prefix": "hypot({i, k}arg1[], iarg2[])",
        "body": "hypot",
        "description": "Euclidean distance function."
    },
    "outkat": {
        "prefix": "outkat(kchn, kvalue, kmin, kmax)",
        "body": "outkat",
        "description": "Sends MIDI aftertouch messages at k-rate."
    },
    "xadsr": {
        "prefix": "xadsr(iatt, idec, islev, irel [, idel])",
        "body": "xadsr",
        "description": "Calculates the classical ADSR envelope."
    },
    "outq4": {
        "prefix": "outq4(asig)",
        "body": "outq4",
        "description": "Writes samples to quad channel 4 of an external device or stream."
    },
    "deltap": {
        "prefix": "deltap(kdlt)",
        "body": "deltap",
        "description": "Taps a delay line at variable offset times."
    },
    "window": {
        "prefix": "window(kin[] [, koff, itype])",
        "body": "window",
        "description": "Applies a given window shape to a vector stored in an array. The output is an array with the windowed vector."
    },
    "vsubv": {
        "prefix": "vsubv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vsubv",
        "description": "Performs subtraction between two vectorial control signals."
    },
    "strlenk": {
        "prefix": "strlenk(Sstr)",
        "body": "strlenk",
        "description": "Return the length of a string, or zero if it is empty. strlenk runs both at init and performance time."
    },
    "soundouts": {
        "prefix": "soundouts(asigl, asigr, ifilcod [, iformat])",
        "body": "soundouts",
        "description": "Deprecated. Writes audio output to a disk file."
    },
    "butbr": {
        "prefix": "butbr(asig, xfreq, xband [, iskip])",
        "body": "butbr",
        "description": "A band-reject Butterworth filter."
    },
    "zamod": {
        "prefix": "zamod(asig, kzamod)",
        "body": "zamod",
        "description": "Modulates one a-rate signal by a second one."
    },
    "sequ": {
        "prefix": "sequ(irhythm[], iinstr[], idata[][], kbpm, klen [, kmode] [, kstep] [, kreset] [, kverbose])",
        "body": "sequ",
        "description": "Emulate a hardware sequencer."
    },
    "slider32table": {
        "prefix": "slider32table(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, ...., ictlnum32, imin32, imax32, init32, ifn32)",
        "body": "slider32table",
        "description": "Stores a bank of 32 different MIDI control messages to a table."
    },
    "buthp": {
        "prefix": "buthp(asig, kfreq [, iskip])",
        "body": "buthp",
        "description": "A high-pass Butterworth filter."
    },
    "strtol": {
        "prefix": "strtol({i, S}str)",
        "body": "strtol",
        "description": "Converts a string to a signed integer value (i-rate)."
    },
    "create": {
        "prefix": "create({opc:OpcodeDef, len: [, overload:i], opc:OpcodeDe [, overload:, code:S, instr:InstrDef})",
        "body": "create",
        "description": "Creates a new instrument definition, instrument instance, or opcode object."
    },
    "#define": {
        "prefix": "#define NAME # replacement text #",
        "body": "#define",
        "description": "Defines a macro."
    },
    "ATSread": {
        "prefix": "ATSread(ktimepnt, iatsfile, ipartial)",
        "body": "ATSread",
        "description": "Reads data from an ATS file."
    },
    "butlp": {
        "prefix": "butlp(asig, kfreq [, iskip])",
        "body": "butlp",
        "description": "A low-pass Butterworth filter."
    },
    "elapsedtime": {
        "prefix": "elapsedtime()",
        "body": "elapsedtime",
        "description": "Read absolute time, in seconds, since the start of the performance."
    },
    "delayr": {
        "prefix": "delayr(idlt [, iskip])",
        "body": "delayr",
        "description": "Reads from an automatically established digital delay line."
    },
    "inleta": {
        "prefix": "inleta(Sname)",
        "body": "inleta",
        "description": "Receives an arate signal into an instrument through a named port."
    },
    "lfsr": {
        "prefix": "lfsr(ilen, iprob [, iseed])",
        "body": "lfsr",
        "description": "Linear Feedback Shift Register (LFSR)."
    },
    "outs1": {
        "prefix": "outs1(asig)",
        "body": "outs1",
        "description": "Writes samples to stereo channel 1 of an external device or stream."
    },
    "vadd_i": {
        "prefix": "vadd_i(ifn, ival, ielements [, idstoffset])",
        "body": "vadd_i",
        "description": "Adds a scalar value to a vector in a table."
    },
    "genarray": {
        "prefix": "genarray({i, k}start, kens [, inc])",
        "body": "genarray",
        "description": "Generate a vector (one-dimensional k-rate or i-rate array) with an arithmetic sequence."
    },
    "MixerSetLevel": {
        "prefix": "MixerSetLevel(isend, ibuss, kgain)",
        "body": "MixerSetLevel",
        "description": "Sets the level at which signals from the send are added to the buss."
    },
    "gain": {
        "prefix": "gain(asig, krms [, ihp] [, iskip])",
        "body": "gain",
        "description": "Adjusts the amplitude audio signal according to a root-mean-square value."
    },
    "scale2": {
        "prefix": "scale2(kinput, kmin, kma [, kimin, kimax][ihtime])",
        "body": "scale2",
        "description": "Arbitrary signal scaling with optional smoothing."
    },
    "pdhalf": {
        "prefix": "pdhalf(ain, kShapeAmount [, ibipolar [, ifullscale]])",
        "body": "pdhalf",
        "description": "Distorts a phasor for reading the two halves of a table at different rates."
    },
    "mvclpf2": {
        "prefix": "mvclpf2(ain, xcf, xre [, istor])",
        "body": "mvclpf2",
        "description": "Moog voltage-controlled lowpass filter emulation."
    },
    "chebyshevpoly": {
        "prefix": "chebyshevpoly(ain, k0 [, k1 [, k2 [...]]])",
        "body": "chebyshevpoly",
        "description": "Efficiently evaluates the sum of Chebyshev polynomials of arbitrary order."
    },
    "vaset": {
        "prefix": "vaset(kval, kndx, avar)",
        "body": "vaset",
        "description": "Write values into the current buffer of an a-rate variable at the given index."
    },
    "aresonk": {
        "prefix": "aresonk(ksig, kcf, kbw [, iscl] [, iskip])",
        "body": "aresonk",
        "description": "A notch filter whose transfer functions are the complements of the reson opcode."
    },
    "tempest": {
        "prefix": "tempest(kin, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, istartempo, ifn [, idisprd] [, itweek])",
        "body": "tempest",
        "description": "Estimate the tempo of beat patterns in a control signal."
    },
    "K35_hpf": {
        "prefix": "K35_hpf(ain, xcf, xQ [, inlp, isaturation, istor])",
        "body": "K35_hpf",
        "description": "Zero-delay feedback implementation of Korg35 resonant high-pass filter."
    },
    "pcauchy": {
        "prefix": "pcauchy(kalpha)",
        "body": "pcauchy",
        "description": "Cauchy distribution random number generator (positive values only)."
    },
    "zdf_ladder": {
        "prefix": "zdf_ladder(ain, xcf, xQ [, istor])",
        "body": "zdf_ladder",
        "description": "Zero-delay feedback implementation of a 4 pole (24 dB/oct) low-pass filter based on the Moog ladder filter."
    },
    "lpsholdp": {
        "prefix": "lpsholdp(kphase, kvalue0, ktime0 [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...])",
        "body": "lpsholdp",
        "description": "Control signals based on held segments."
    },
    "signum": {
        "prefix": "signum(x)",
        "body": "signum",
        "description": "Returns the signum of _x_ returning -1, 0 or 1."
    },
    "turnon": {
        "prefix": "turnon(insnum [, itime])",
        "body": "turnon",
        "description": "Activate an instrument for an indefinite time."
    },
    "endif": {
        "prefix": "endif",
        "body": "endif",
        "description": "Closes a block of code that begins with an [&quot;if...then&quot;] statement."
    },
    "arduinoRead": {
        "prefix": "arduinoRead(iPort, iStream [, iSmooth])",
        "body": "arduinoRead",
        "description": "Read integer data from an arduino port using the Csound-Arduino protocol."
    },
    "mandol": {
        "prefix": "mandol(kamp, kfreq, kpluck, kdetune, kgain, ksize [, ifn] [, iminfreq])",
        "body": "mandol",
        "description": "An emulation of a mandolin."
    },
    "vclpf": {
        "prefix": "vclpf(ain, xcf, xre [, istor])",
        "body": "vclpf",
        "description": "Resonant 4pole linear lowpass filter."
    },
    "sfplay": {
        "prefix": "sfplay(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])",
        "body": "sfplay",
        "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound."
    },
    "biquad": {
        "prefix": "biquad(asig, kb0, kb1, kb2, ka0, ka1, ka2 [, iskip])",
        "body": "biquad",
        "description": "A sweepable general purpose biquadratic digital filter."
    },
    "octmidinn": {
        "prefix": "octmidinn(MidiNoteNumber)",
        "body": "octmidinn",
        "description": "Converts a Midi note number value to octave-point-decimal."
    },
    "foutir": {
        "prefix": "foutir(ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN])",
        "body": "foutir",
        "description": "Outputs i-rate signals from an arbitrary number of channels to a specified file."
    },
    "getseed": {
        "prefix": "getseed()",
        "body": "getseed",
        "description": "Reads the global seed value."
    },
    "tab2array": {
        "prefix": "tab2array(ifn [, kstart, kend, kstep ])",
        "body": "tab2array",
        "description": "Copy a slice from an f-table to an array."
    },
    "pvsbin": {
        "prefix": "pvsbin(fsig, kbin)",
        "body": "pvsbin",
        "description": "Obtain the amp and freq values off a PVS signal bin as k-rate variables."
    },
    "gogobel": {
        "prefix": "gogobel(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivfn)",
        "body": "gogobel",
        "description": "Audio output is a tone related to the striking of a cow bell or similar."
    },
    "fmrhode": {
        "prefix": "fmrhode(kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn)",
        "body": "fmrhode",
        "description": "Uses FM synthesis to create a Fender Rhodes electric piano sound."
    },
    "serialWrite_i": {
        "prefix": "serialWrite_i(iPort, iByte)",
        "body": "serialWrite_i",
        "description": "Write data to a serial port for arduino."
    },
    "mediank": {
        "prefix": "mediank(kin, ksize, imaxsize [, iskip])",
        "body": "mediank",
        "description": "A median filter, a variant FIR lowpass filter."
    },
    "sinsyn": {
        "prefix": "sinsyn(fin, kscal, kmaxtracks, ifn)",
        "body": "sinsyn",
        "description": "Streaming partial track additive synthesis with cubic phase interpolation."
    },
    "tablegpw": {
        "prefix": "tablegpw(kfn)",
        "body": "tablegpw",
        "description": "Writes a table&#x27;s guard point."
    },
    "zawm": {
        "prefix": "zawm(asig, kndx [, imix])",
        "body": "zawm",
        "description": "Writes to a za variable at a-rate with mixing."
    },
    "fini": {
        "prefix": "fini(ifilename, iskipframes, iformat, in1 [, in2] [, in3] [, ...])",
        "body": "fini",
        "description": "Read signals from a file at i-rate."
    },
    "perf": {
        "prefix": "perf({opc:Opcod [, arg1:*, ...], ins:Inst [, p4:k, ...]})",
        "body": "perf",
        "description": "Execute a performance pass on an instrument or opcode."
    },
    "oscilikt": {
        "prefix": "oscilikt({x, k}amp, xcps, kfn [, iphs] [, istor])",
        "body": "oscilikt",
        "description": "A linearly interpolated oscillator that allows changing the table number at k-rate."
    },
    "trhighest": {
        "prefix": "trhighest(fin1, kscal)",
        "body": "trhighest",
        "description": "Extracts the highest-frequency track from a streaming track input signal."
    },
    "vco2ift": {
        "prefix": "vco2ift(icps, iwave [, inyx])",
        "body": "vco2ift",
        "description": "Returns a table number at i-time for a given oscillator frequency and wavform."
    },
    "==": {
        "prefix": "(a == b ? v1 : v2)",
        "body": "==",
        "description": "Compares two values for equality."
    },
    "sfpreset": {
        "prefix": "sfpreset(iprog, ibank, ifilhandle, ipreindex)",
        "body": "sfpreset",
        "description": "Assigns an existing preset of a previously loaded SoundFont2 (SF2) sample file to an index number."
    },
    "outs": {
        "prefix": "outs(asig1, asig2)",
        "body": "outs",
        "description": "Writes stereo audio data to an external device or stream."
    },
    "ficlose": {
        "prefix": "ficlose({i, S}handle)",
        "body": "ficlose",
        "description": "Closes a previously opened file."
    },
    "specfilt": {
        "prefix": "specfilt(wsigin, ifhtim)",
        "body": "specfilt",
        "description": "Filters each channel of an input spectrum."
    },
    "trigexpseg": {
        "prefix": "trigexpseg(kTrig, ia, idur1, ib [, idur2] [, ic] [...])",
        "body": "trigexpseg",
        "description": "Triggers a series of exponential segments between specified points."
    },
    "zdf_1pole_mode": {
        "prefix": "zdf_1pole_mode(ain, xcf [, istor])",
        "body": "zdf_1pole_mode",
        "description": "Zero-delay feedback implementation of 1 pole (6 dB/oct) filter with multimode output."
    },
    "trscale": {
        "prefix": "trscale(fin, kpitch [, kgain])",
        "body": "trscale",
        "description": "Streaming partial track frequency scaling."
    },
    "polar": {
        "prefix": "polar(var:Complex)",
        "body": "polar",
        "description": "Returns a complex number in polar format."
    },
    "ino": {
        "prefix": "ino()",
        "body": "ino",
        "description": "Reads eight-channel audio data from an external device or stream."
    },
    "readk2": {
        "prefix": "readk2(ifilname, iformat, iprd)",
        "body": "readk2",
        "description": "Periodically reads two orchestra control-signal values from an external file."
    },
    "vco2ft": {
        "prefix": "vco2ft(kcps, iwave [, inyx])",
        "body": "vco2ft",
        "description": "Returns a table number at k-time for a given oscillator frequency and wavform."
    },
    "envlpx": {
        "prefix": "envlpx({x, k}amp, irise, idur, idec, ifn, iatss, iatdec [, ixmod])",
        "body": "envlpx",
        "description": "Applies an envelope consisting of 3 segments."
    },
    "pvsceps": {
        "prefix": "pvsceps(fsi [, icoefs])",
        "body": "pvsceps",
        "description": "Calculate the cepstrum of a pvs input, optionally liftering coefficients."
    },
    "foutk": {
        "prefix": "foutk(ifilename, iformat, kout1 [, kout2, kout3,....,koutN])",
        "body": "foutk",
        "description": "Outputs k-rate signals of an arbitrary number of channels to a specified file, in raw (headerless) format."
    },
    "scanmap": {
        "prefix": "scanmap(iscan, kamp, kvamp [, iwhich])",
        "body": "scanmap",
        "description": "Allows the position and velocity of a node in a scanned process to be read."
    },
    "sflooper": {
        "prefix": "sflooper(ivel, inotenum, kamp, kpitch, ipreindex, kloopstart, kloopend, kcrossfade [, istart, imode, ifenv, iskip, iflag])",
        "body": "sflooper",
        "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound, with user-defined"
    },
    "vcopy": {
        "prefix": "vcopy(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [, kverbose])",
        "body": "vcopy",
        "description": "Copies between two vectorial control signals."
    },
    "looptseg": {
        "prefix": "looptseg(kfreq, ktrig, iphase, kvalue0, ktype0, ktime0 [, kvalue1] [,ktype1] [, ktime1] [, kvalue2] [,ktype2] [, ktime2] [...] [, kvalueN] [,ktypeN] [, ktimeN])",
        "body": "looptseg",
        "description": "Generate control signal consisting of exponential or linear segments delimited by two or more specified points."
    },
    "minarray": {
        "prefix": "minarray(karray)",
        "body": "minarray",
        "description": "Returns the minimum value in a k-rate array, and optional its index."
    },
    "deltapn": {
        "prefix": "deltapn(xnumsamps)",
        "body": "deltapn",
        "description": "Taps a delay line at variable offset times."
    },
    "spsend": {
        "prefix": "spsend()",
        "body": "spsend",
        "description": "Generates output signals based on a previously defined [space] opcode."
    },
    "fareyleni": {
        "prefix": "fareyleni(ifn)",
        "body": "fareyleni",
        "description": "Returns the length of a Farey Sequence."
    },
    "vecdelay": {
        "prefix": "vecdelay(ifn, ifnIn, ifnDel, ielements, imaxdel [, iskip])",
        "body": "vecdelay",
        "description": "Generate a sort of &#x27;vectorial&#x27; delay."
    },
    "ctrl7": {
        "prefix": "ctrl7(ichan, ictlno, imin, imax [, ifn])",
        "body": "ctrl7",
        "description": "Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "maxabs": {
        "prefix": "maxabs({a, k}in1, ain2 [, ain3] [, ain4] [...])",
        "body": "maxabs",
        "description": "Produces a signal that is the maximum of the absolute values of any number of input signals."
    },
    "xyscale": {
        "prefix": "xyscale(kx, ky, k00, k10, k01, k11)",
        "body": "xyscale",
        "description": "2D linear interpolation."
    },
    "phaser1": {
        "prefix": "phaser1(asig, kfreq, kord, kfeedback [, iskip])",
        "body": "phaser1",
        "description": "First-order allpass filters arranged in a series."
    },
    "nstance": {
        "prefix": "nstance(insnum, iwhen, idur [, ip4] [, ip5] [...])",
        "body": "nstance",
        "description": "Schedules a new instrument instance, storing the instance handle in a variable."
    },
    "wgbrass": {
        "prefix": "wgbrass(kamp, kfreq, ktens, iatt, kvibf, kvamp [, ifn] [, iminfreq])",
        "body": "wgbrass",
        "description": "Creates a tone related to a brass instrument."
    },
    "*": {
        "prefix": "a * b  (no rate restriction)",
        "body": "*",
        "description": "Multiplication operator."
    },
    "tableiw": {
        "prefix": "tableiw(isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode])",
        "body": "tableiw",
        "description": "Deprecated as of version 3.49. Use the [tablew] opcode instead."
    },
    "port": {
        "prefix": "port(ksig, ihtim [, isig])",
        "body": "port",
        "description": "Applies portamento to a step-valued control signal."
    },
    "outletv": {
        "prefix": "outletv(Sname, array)",
        "body": "outletv",
        "description": "Sends an arate array signal out from an instrument to a named port."
    },
    "scalearray": {
        "prefix": "scalearray(tarray, kmin, kma [, kleft, kright])",
        "body": "scalearray",
        "description": "The _scalearray_ opcode scales a subregion of a vector to a given minimum/maximum."
    },
    "mpulse": {
        "prefix": "mpulse(kamp, kintvl [, ioffset])",
        "body": "mpulse",
        "description": "Generates a set of impulses."
    },
    "0dbfs": {
        "prefix": "0dbfs = iarg",
        "body": "0dbfs",
        "description": "Sets the value of 0 decibels using full scale amplitude."
    },
    "fillarray": {
        "prefix": "fillarray({i, k}val1, ival2,.....ivaln)",
        "body": "fillarray",
        "description": "Generate a vector (one-dimensional k-rate array) with a sequence of"
    },
    "slider64f": {
        "prefix": "slider64f(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ..., ictlnum64, imin64, imax64, init64, ifn64, icutoff64)",
        "body": "slider64f",
        "description": "Creates a bank of 64 different MIDI control message numbers, filtered before output."
    },
    "getcol": {
        "prefix": "getcol(i/kin[], i/kcol)",
        "body": "getcol",
        "description": "Gets a given column from a 2-dimensional array as a vector."
    },
    "taninv": {
        "prefix": "taninv(x)",
        "body": "taninv",
        "description": "Returns the arctangent of _x_ (_x_ in radians)."
    },
    "bpf": {
        "prefix": "bpf({i, a, k}x, kx1, ky1, kx2, ..., kxn, kyn)",
        "body": "bpf",
        "description": "Break point function with linear interpolation."
    },
    "pvscale": {
        "prefix": "pvscale(fsigin, kscal [, kkeepform, kgain, kcoefs])",
        "body": "pvscale",
        "description": "Scale the frequency components of a pv stream, resulting in pitch shift."
    },
    "cossegr": {
        "prefix": "cossegr(ia, idur1, ib [, idur2] [, ic] [...], irel, iz)",
        "body": "cossegr",
        "description": "Trace a series of line segments between specified points with"
    },
    "inch": {
        "prefix": "inch(kchan1[,...])",
        "body": "inch",
        "description": "Reads from numbered channels in an external audio signal or stream."
    },
    "sandpaper": {
        "prefix": "sandpaper(iamp, idettack [, inum] [, idamp] [, imaxshake])",
        "body": "sandpaper",
        "description": "Semi-physical model of a sandpaper sound."
    },
    "sndwarp": {
        "prefix": "sndwarp(xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, irandw, ioverlap, ifn2, itimemode)",
        "body": "sndwarp",
        "description": "Reads a mono sound sample from a table and applies time-stretching and/or pitch modification."
    },
    "subinstr": {
        "prefix": "subinstr(instrnum [, p4] [, p5] [...])",
        "body": "subinstr",
        "description": "Creates and runs a numbered instrument instance as if it were an opcode."
    },
    "subinstrinit": {
        "prefix": "subinstrinit(instrnum [, p4] [, p5] [...])",
        "body": "subinstrinit",
        "description": "Creates and runs a numbered instrument instance as if it were an opcode."
    },
    "tableshuffle": {
        "prefix": "tableshuffle(ktablenum)",
        "body": "tableshuffle",
        "description": "Shuffles the content of a function table."
    },
    "elapsedcycles": {
        "prefix": "elapsedcycles()",
        "body": "elapsedcycles",
        "description": "Read absolute time, in k-rate cycles, since the start of the performance."
    },
    "pow": {
        "prefix": "pow({a, i, k}arg, k)",
        "body": "pow",
        "description": "Computes one argument to the power of another argument and scales the result."
    },
    "A4": {
        "prefix": "A4 = iarg",
        "body": "A4",
        "description": "Sets the base frequency for pitch A4."
    },
    "system": {
        "prefix": "system({i, k}trig, Scmd, [inowait])",
        "body": "system",
        "description": "Call an external program via the system call."
    },
    "ctrlinit": {
        "prefix": "ctrlinit(ichnl, ictlno1, ival1 [, ictlno2] [, ival2] [, ictlno3] [, ival3] [,...ival32])",
        "body": "ctrlinit",
        "description": "Sets the initial values for a set of MIDI controllers."
    },
    "hvs1": {
        "prefix": "hvs1(kx, inumParms, inumPointsX, iOutTab, iPositionsTab, iSnapTab [, iConfigTab])",
        "body": "hvs1",
        "description": "Allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables."
    },
    "OSCinit": {
        "prefix": "OSCinit(iport)",
        "body": "OSCinit",
        "description": "Start a listening process for OSC messages to a particular port."
    },
    "ins": {
        "prefix": "ins()",
        "body": "ins",
        "description": "Reads stereo audio data from an external device or stream."
    },
    "bpfcos": {
        "prefix": "bpfcos(kx, kx1, ky1, kx2, ..., kxn, kyn)",
        "body": "bpfcos",
        "description": "Break point function with cosine (easy-in/easy-out) interpolation."
    },
    "event": {
        "prefix": "event(\"scorechar\", kinsnum, kdelay, kdur [, kp4] [, kp5] [, ...])",
        "body": "event",
        "description": "Generates a score event from an instrument."
    },
    "jitter": {
        "prefix": "jitter(kamp, kcpsMin, kcpsMax)",
        "body": "jitter",
        "description": "Generates a segmented line whose segments are randomly generated."
    },
    "dam": {
        "prefix": "dam(asig, kthreshold, icomp1, icomp2, irtime, iftime)",
        "body": "dam",
        "description": "A dynamic compressor/expander."
    },
    "vcopy_i": {
        "prefix": "vcopy_i(ifn1, ifn2, ielements [,idstoffset, isrcoffset])",
        "body": "vcopy_i",
        "description": "Copies a vector from one table to another."
    },
    "ftlen": {
        "prefix": "ftlen(x)",
        "body": "ftlen",
        "description": "Returns the size of a stored function table."
    },
    "vdivv_i": {
        "prefix": "vdivv_i(ifn1, ifn2, ielements [, idstoffset] [, isrcoffset])",
        "body": "vdivv_i",
        "description": "Performs division between two vectorial control signals at init time."
    },
    "pindex": {
        "prefix": "pindex(ipfieldIndex)",
        "body": "pindex",
        "description": "Returns the value of a specified pfield."
    },
    "outo": {
        "prefix": "outo(asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8)",
        "body": "outo",
        "description": "Writes 8-channel audio data to an external device or stream."
    },
    "midifileopen": {
        "prefix": "midifileopen(name: [, port:i])",
        "body": "midifileopen",
        "description": "Open a MIDI file for playback. "
    },
    "fof2": {
        "prefix": "fof2(xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss [, iskip])",
        "body": "fof2",
        "description": "Produces sinusoid bursts including k-rate incremental indexing with each successive burst."
    },
    "vtaba": {
        "prefix": "vtaba(andx, ifn, aout1 [, aout2, aout3, .... , aoutN ])",
        "body": "vtaba",
        "description": "Read vectors (from tables -or arrays of vectors) at a-rate."
    },
    "tabmorphi": {
        "prefix": "tabmorphi(kindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 [, ifn3, ifn4, ..., ifnN])",
        "body": "tabmorphi",
        "description": "Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables."
    },
    "lpf18": {
        "prefix": "lpf18(asig, xfco, xres, xdist [, iskip])",
        "body": "lpf18",
        "description": "A 3-pole sweepable resonant lowpass filter."
    },
    "strrindexk": {
        "prefix": "strrindexk(S1, S2)",
        "body": "strrindexk",
        "description": "Return the position of the last occurence of S2 in S1, or -1 if not found. If S2 is empty, the length of S1 is returned."
    },
    "flooper2": {
        "prefix": "flooper2(kamp, kpitch, kloopstart, kloopend, kcrossfade, ifn [, istart, imode, ifenv, iskip])",
        "body": "flooper2",
        "description": "Function-table-based crossfading looper."
    },
    "inletkid": {
        "prefix": "inletkid(Sname, SinstanceID)",
        "body": "inletkid",
        "description": "Receives a krate signal into an instrument from a named port."
    },
    "xyin": {
        "prefix": "xyin(iprd, ixmin, ixmax, iymin, iymax [, ixinit] [, iyinit])",
        "body": "xyin",
        "description": "Sense the cursor position in an output window."
    },
    "sfplay3m": {
        "prefix": "sfplay3m(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])",
        "body": "sfplay3m",
        "description": "Plays a SoundFont2 (SF2) sample preset, generating a mono sound with cubic interpolation."
    },
    "linsegb": {
        "prefix": "linsegb(ia, itim1, ib [, itim2] [, ic] [...])",
        "body": "linsegb",
        "description": "Trace a series of line segments between specified absolute points."
    },
    "vdelayxwq": {
        "prefix": "vdelayxwq(ain1, ain2, ain3, ain4, adl, imd, iws [, ist])",
        "body": "vdelayxwq",
        "description": "Variable delay opcodes with high quality interpolation."
    },
    "mags": {
        "prefix": "mags(kin[])",
        "body": "mags",
        "description": "Obtains the magnitudes of a complex-number array."
    },
    "polyaft": {
        "prefix": "polyaft(inote [, ilow] [, ihigh])",
        "body": "polyaft",
        "description": "Returns the polyphonic after-touch pressure of the selected note number, optionally mapped to an user-specified range."
    },
    "dcblock": {
        "prefix": "dcblock(ain [, igain])",
        "body": "dcblock",
        "description": "Implements the DC blocking filter."
    },
    "cigoto": {
        "prefix": "cigoto(condition, label)",
        "body": "cigoto",
        "description": "During the i-time pass only, conditionally transfer control to the statement labeled by _label_."
    },
    "pol2rect": {
        "prefix": "pol2rect(kin[])",
        "body": "pol2rect",
        "description": "Converts an input array in magnitude-phase format to real-imaginary format."
    },
    "nlfilt2": {
        "prefix": "nlfilt2(ain, ka, kb, kd, kC, kL)",
        "body": "nlfilt2",
        "description": "A filter with a non-linear effect and blowup protection."
    },
    "oscil1i": {
        "prefix": "oscil1i(idel, kamp, idur [, ifn])",
        "body": "oscil1i",
        "description": "Accesses table values by incremental sampling with linear interpolation."
    },
    "serialFlush": {
        "prefix": "serialFlush(iPort)",
        "body": "serialFlush",
        "description": "Flush data from a serial port."
    },
    "vcella": {
        "prefix": "vcella(ktrig, kreinit, ioutFunc, initStateFunc, iRuleFunc, ielements, irulelen [, iradius])",
        "body": "vcella",
        "description": "Cellular Automata."
    },
    "rbjeq": {
        "prefix": "rbjeq(asig, kfco, klvl, kQ, k [, imode])",
        "body": "rbjeq",
        "description": "Parametric equalizer and filter opcode with 7 filter types, based on algorithm by Robert Bristow-Johnson."
    },
    "metro": {
        "prefix": "metro(freq [, initphase])",
        "body": "metro",
        "description": "Trigger Metronome."
    },
    "tabsum": {
        "prefix": "tabsum(ifn [, kmin] [, kmax]])",
        "body": "tabsum",
        "description": "Sums the values in an f-table in a consecutive range."
    },
    "randomi": {
        "prefix": "randomi(kmin, kmax, xcps [,imode] [,ifirstval])",
        "body": "randomi",
        "description": "Generates a user-controlled random number series with interpolation between each new number."
    },
    "strlen": {
        "prefix": "strlen(Sstr)",
        "body": "strlen",
        "description": "Return the length of a string, or zero if it is empty. strlen runs at init time only."
    },
    "slider64tablef": {
        "prefix": "slider64tablef(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ...., ictlnum64, imin64, imax64, init64, ifn64, icutoff64)",
        "body": "slider64tablef",
        "description": "Stores a bank of 64 different MIDI control messages to a table, filtered before output."
    },
    "partikkelset": {
        "prefix": "partikkelset(kparameterindex, kmaskindex, iopcode_id)",
        "body": "partikkelset",
        "description": "Set mask index for a specific mask parameter of a running _partikkel_ instance."
    },
    "specptrk": {
        "prefix": "specptrk(wsig, kvar, ilo, ihi, istr, idbthresh, inptls, irolloff [, iodd] [, iconfs] [, interp] [, ifprd] [, iwtflg])",
        "body": "specptrk",
        "description": "Estimates the pitch of the most prominent complex tone in the spectrum."
    },
    "wgbow": {
        "prefix": "wgbow(kamp, kfreq, kpres, krat, kvibf, kvamp [, ifn] [, iminfreq])",
        "body": "wgbow",
        "description": "Creates a tone similar to a bowed string."
    },
    "cpstmid": {
        "prefix": "cpstmid(ifn)",
        "body": "cpstmid",
        "description": "Get a MIDI note number (allows customized micro-tuning scales)."
    },
    "urd": {
        "prefix": "aout",
        "body": "urd",
        "description": "A discrete user-defined-distribution random generator that can be used as a function."
    },
    "db": {
        "prefix": "db(x)",
        "body": "db",
        "description": "Returns the amplitude equivalent for a given decibel amount."
    },
    "max": {
        "prefix": "max({i, a, k}in1, ain2 [, ain3] [, ain4] [...])",
        "body": "max",
        "description": "Produces a signal that is the maximum of any number of input signals."
    },
    "tabw_i": {
        "prefix": "tabw_i(isig, indx, ifn [,ixmode])",
        "body": "tabw_i",
        "description": "Fast table opcodes."
    },
    "lorenz": {
        "prefix": "lorenz(ksv, krv, kbv, kh, ix, iy, iz, iskip [, iskipinit])",
        "body": "lorenz",
        "description": "Implements the Lorenz system of equations."
    },
    "outq1": {
        "prefix": "outq1(asig)",
        "body": "outq1",
        "description": "Writes samples to quad channel 1 of an external device or stream."
    },
    "sndloop": {
        "prefix": "sndloop(ain, kpitch, ktrig, idur, ifad)",
        "body": "sndloop",
        "description": "A sound looper with pitch control."
    },
    "squinewave": {
        "prefix": "squinewave(acps, aClip, aSkew, asyncin [, iMinSweep] [, iphase])",
        "body": "squinewave",
        "description": "A mostly bandlimited shape-shifting square-pulse-saw-sinewave oscillator with hardsync."
    },
    "mincer": {
        "prefix": "mincer(atimpt, kamp, kpitch, ktab, klock [ ,ifftsize, idecim])",
        "body": "mincer",
        "description": "Phase-locked vocoder processing."
    },
    "!": {
        "prefix": "! a  (logical NOT; not audio-rate)",
        "body": "!",
        "description": "Logical NOT operator."
    },
    "rireturn": {
        "prefix": "rireturn()",
        "body": "rireturn",
        "description": "Terminates a [reinit] pass (i.e., no-op at standard i-time)."
    },
    "pvsbufread2": {
        "prefix": "pvsbufread2(ktime, khandle, ift1, ift2)",
        "body": "pvsbufread2",
        "description": "This opcode reads a circular buffer of f-signals (streaming PV signals), with binwise additional delays."
    },
    "osciliktp": {
        "prefix": "osciliktp(kcps, kfn, kphs [, istor])",
        "body": "osciliktp",
        "description": "A linearly interpolated oscillator that allows allows phase modulation."
    },
    "strcat": {
        "prefix": "strcat(Ssrc1, Ssrc2)",
        "body": "strcat",
        "description": "Concatenate two strings and store the result in a variable."
    },
    "vaddv": {
        "prefix": "vaddv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vaddv",
        "description": "Performs addition between two vectorial control signals."
    },
    "sfplay3": {
        "prefix": "sfplay3(ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv])",
        "body": "sfplay3",
        "description": "Plays a SoundFont2 (SF2) sample preset, generating a stereo sound with cubic interpolation."
    },
    "tival": {
        "prefix": "tival()",
        "body": "tival",
        "description": "Puts the value of the instrument&#x27;s internal &amp;#8220;tie-in&amp;#8221; flag into the named i-rate variable."
    },
    "floor": {
        "prefix": "floor(x)",
        "body": "floor",
        "description": "Returns the largest integer not greater than *x*."
    },
    "mtof": {
        "prefix": "mtof({i, k}midi)",
        "body": "mtof",
        "description": "Convert a midi note number value to frequency, taking global value of A4 into account."
    },
    "hilbert": {
        "prefix": "hilbert(sig:a)",
        "body": "hilbert",
        "description": "A Hilbert transformer."
    },
    "slider16f": {
        "prefix": "slider16f(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ..., ictlnum16, imin16, imax16, init16, ifn16, icutoff16)",
        "body": "slider16f",
        "description": "Creates a bank of 16 different MIDI control message numbers, filtered before output."
    },
    "vadd": {
        "prefix": "vadd(ifn, kval, kelements [, kdstoffset] [, kverbose])",
        "body": "vadd",
        "description": "Adds a scalar value to a vector in a table."
    },
    "reverb2": {
        "prefix": "reverb2(asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] [, inumAlpas] [, ifnAlpas])",
        "body": "reverb2",
        "description": "A reverberator consisting of 6 parallel comb-lowpass filters."
    },
    "logcurve": {
        "prefix": "logcurve(kindex, ksteepness)",
        "body": "logcurve",
        "description": "This opcode implements a formula for generating a normalised logarithmic curve in range 0 - 1. It is based on the Max / MSP work of Eric Singer (c) 1994."
    },
    "inx": {
        "prefix": "inx()",
        "body": "inx",
        "description": "Reads a 16-channel audio signal from an external device or stream."
    },
    "real": {
        "prefix": "real(var:Complex)",
        "body": "real",
        "description": "Returns the real part of a complex number."
    },
    "sockrecv": {
        "prefix": "sockrecv({i, S}port, ilength)",
        "body": "sockrecv",
        "description": "Receives data from other processes using the low-level UDP or TCP protocols."
    },
    "printk2": {
        "prefix": "printk2(kvar [, inumspaces] [, inamed])",
        "body": "printk2",
        "description": "Prints a new value every time a control variable changes."
    },
    "vactrol": {
        "prefix": "vactrol(asig [iup, idown])",
        "body": "vactrol",
        "description": "Envelope follower unit generator emmulating a Perkin Elmer Vactrole VTL5C3/2."
    },
    "vbapz": {
        "prefix": "vbapz(inumchnls, istartndx, asig, kazim [, kelev] [, kspread])",
        "body": "vbapz",
        "description": "Writes a multi-channel audio signal to a ZAK array."
    },
    "midifilepause": {
        "prefix": "midifilepause([id:i])",
        "body": "midifilepause",
        "description": "Pauses MIDI file playback. "
    },
    "pvsosc": {
        "prefix": "pvsosc(kamp, kfreq, ktype, isize [,ioverlap] [, iwinsize] [, iwintype] [, iformat])",
        "body": "pvsosc",
        "description": "PVS-based oscillator simulator."
    },
    "phasorbnk": {
        "prefix": "phasorbnk({x, k}cps, kndx, icnt [, iphs])",
        "body": "phasorbnk",
        "description": "Produce an arbitrary number of normalized moving phase values, accessable by an index."
    },
    "eventcycles": {
        "prefix": "eventcycles()",
        "body": "eventcycles",
        "description": "Read absolute time in k-rate cycles, since the start of an instance of an instrument."
    },
    "slider8f": {
        "prefix": "slider8f(ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ..., ictlnum8, imin8, imax8, init8, ifn8, icutoff8)",
        "body": "slider8f",
        "description": "Creates a bank of 8 different MIDI control message numbers, filtered before output."
    },
    "slicearray": {
        "prefix": "slicearray(kinarray, istart, iend [,istride])",
        "body": "slicearray",
        "description": "Take a slice of a vector (one-dimensional k-rate array)."
    },
    "ATSbufread": {
        "prefix": "ATSbufread(ktimepnt, kfmod, iatsfile, ipartials [, ipartialoffset, ipartialincr])",
        "body": "ATSbufread",
        "description": "Reads data from and ATS data file and stores it in an internal data table of frequency, amplitude pairs."
    },
    "chnset": {
        "prefix": "chnset({a, i, S, k}val, Sname)",
        "body": "chnset",
        "description": "Writes data to a channel of the named software bus."
    },
    "shiftout": {
        "prefix": "shiftout(kIn[] [, ioff])",
        "body": "shiftout",
        "description": "Shifts the contents of a 1-dimensional array into an audio variable."
    },
    "in": {
        "prefix": "in()",
        "body": "in",
        "description": "Reads mono audio data from an external device or stream."
    },
    "pconvolve": {
        "prefix": "pconvolve(ain, ifilcod [, ipartitionsize [, ichannel]])",
        "body": "pconvolve",
        "description": "Convolution based on a uniformly partitioned overlap-save algorithm."
    },
    "fractalnoise": {
        "prefix": "fractalnoise(kamp, kbeta)",
        "body": "fractalnoise",
        "description": "A fractal noise generator."
    },
    "kr": {
        "prefix": "kr = iarg",
        "body": "kr",
        "description": "Sets the control rate."
    },
    "outleta": {
        "prefix": "outleta(Sname, asignal)",
        "body": "outleta",
        "description": "Sends an arate signal out from an instrument to a named port."
    },
    "cosinv": {
        "prefix": "cosinv(x)",
        "body": "cosinv",
        "description": "Returns the arccosine of _x_ (_x_ in radians)."
    },
    "OSCraw": {
        "prefix": "OSCraw(iport)",
        "body": "OSCraw",
        "description": "Listen for all OSC messages at a given port."
    },
    "adsr": {
        "prefix": "adsr(iatt, idec, islev, irel [, idel])",
        "body": "adsr",
        "description": "Calculates the classical ADSR envelope using linear segments."
    },
    "lfo": {
        "prefix": "lfo(kamp, kcps [, itype])",
        "body": "lfo",
        "description": "A low frequency oscillator of various shapes."
    },
    "scanu": {
        "prefix": "scanu(init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id)",
        "body": "scanu",
        "description": "Compute the waveform and the wavetable for use in scanned synthesis."
    },
    "unwrap": {
        "prefix": "unwrap(kin[])",
        "body": "unwrap",
        "description": "Applies a unwrapping operation to a vector of phase values stored in an array."
    },
    "vport": {
        "prefix": "vport(ifn, khtime, ielements [, ifnInit])",
        "body": "vport",
        "description": "Generate a sort of &#x27;vectorial&#x27; portamento."
    },
    "oversample": {
        "prefix": "oversample(ifactor [,icvt_in, icvt_out])",
        "body": "oversample",
        "description": "Sets the local sampling rate value in a user-defined opcode block."
    },
    "mp3scal": {
        "prefix": "mp3scal(Sfile, ktimescal, kpitch, kamp [, iskip, ifftsize, idecim, ilock])",
        "body": "mp3scal",
        "description": "Phase-locked vocoder processing with onset detection/processing, &#x27;tempo-scaling&#x27;."
    },
    "chnmix": {
        "prefix": "chnmix(aval, Sname)",
        "body": "chnmix",
        "description": "Writes audio data to the named software bus, mixing to the previous output."
    },
    "fmvoice": {
        "prefix": "fmvoice(kamp, kfreq, kvowel, ktilt, kvibamt, kvibrat [, ifn1, ifn2, ifn3, ifn4, ivibfn])",
        "body": "fmvoice",
        "description": "FM Singing Voice Synthesis."
    },
    "zkcl": {
        "prefix": "zkcl(kfirst, klast)",
        "body": "zkcl",
        "description": "Clears one or more variables in the zk space."
    },
    "dust2": {
        "prefix": "dust2(kamp, kdensity)",
        "body": "dust2",
        "description": "Generates random impulses from -1 to 1."
    },
    "ceps": {
        "prefix": "ceps(kmags[] [, icoefs])",
        "body": "ceps",
        "description": "Calculate the cepstrum of an array input, optionally filtering coefficients."
    },
    "ptrack": {
        "prefix": "ptrack(asig, ihopsize[,ipeaks])",
        "body": "ptrack",
        "description": "Tracks the pitch of a signal."
    },
    "apoleparams": {
        "prefix": "apoleparams(kCoef[])",
        "body": "apoleparams",
        "description": "Extracts allpole filter parameters from coefficients."
    },
    "midremot": {
        "prefix": "midremot(idestination, isource, instrnum [, instrnum...])",
        "body": "midremot",
        "description": "An opcode which can be used to implement a remote midi orchestra. This opcode will send midi events from a source machine to one destination."
    },
    "ftgen": {
        "prefix": "ftgen(ifn, itime, isize, igen, iarga [, iargb ] [...])",
        "body": "ftgen",
        "description": "Generate a score function table from within the orchestra."
    },
    ">=": {
        "prefix": "(a >= b ? v1 : v2)",
        "body": ">=",
        "description": "Determines if one value is greater than or equal to another."
    },
    "||": {
        "prefix": "a || b  (logical OR; not audio-rate)",
        "body": "||",
        "description": "Logical OR operator."
    },
    "printf": {
        "prefix": "printf(Sfmt, itrig, [iarg [, iarg [, ... ]]])",
        "body": "printf",
        "description": "printf-style formatted output."
    },
    "cntCycles": {
        "prefix": "cntCycles(icnt)",
        "body": "cntCycles",
        "description": "Get the number of times a counter has cycled."
    },
    "&&": {
        "prefix": "a && b  (logical AND; not audio-rate)",
        "body": "&&",
        "description": "Logical AND operator."
    },
    "abs": {
        "prefix": "abs(var:{i,k,a})",
        "body": "abs",
        "description": "Returns the absolute value of its input."
    },
    "MixerSend": {
        "prefix": "MixerSend(asignal, isend, ibuss, ichannel)",
        "body": "MixerSend",
        "description": "Mixes an arate signal into a channel of a buss."
    },
    "tabifd": {
        "prefix": "tabifd(ktimpt, kamp, kpitch, ifftsize, ihopsize, iwintype,ifn)",
        "body": "tabifd",
        "description": "Instantaneous Frequency Distribution, magnitude and phase analysis."
    },
    "zkw": {
        "prefix": "zkw(kval, kndx)",
        "body": "zkw",
        "description": "Writes to a zk variable at k-rate without mixing."
    },
    "fmanal": {
        "prefix": "fmanal(are, aim)",
        "body": "fmanal",
        "description": "AM/FM analysis from quadrature signal."
    },
    "midiin": {
        "prefix": "midiin()",
        "body": "midiin",
        "description": "Returns a generic MIDI message received by the MIDI IN port."
    },
    "inletv": {
        "prefix": "inletv(Sname)",
        "body": "inletv",
        "description": "Receives an arate array signal into an instrument through a named port."
    },
    "fofilter": {
        "prefix": "fofilter(ain, xcf, xris, xde [, istor])",
        "body": "fofilter",
        "description": "Formant filter."
    },
    "midion2": {
        "prefix": "midion2(kchn, knum, kvel, ktrig)",
        "body": "midion2",
        "description": "Sends noteon and noteoff messages to the MIDI OUT port when triggered by a value different than zero."
    },
    "tableicopy": {
        "prefix": "tableicopy(idft, isft)",
        "body": "tableicopy",
        "description": "Simple, fast table copy opcode."
    },
    "pvshift": {
        "prefix": "pvshift(fsigin, kshift, klowest [, kkeepform, igain, kcoefs])",
        "body": "pvshift",
        "description": "Shift the frequency components of a pv stream, stretching/compressing its spectrum."
    },
    "convle": {
        "prefix": "convle(ain, ifilcod [, ichannel])",
        "body": "convle",
        "description": "Convolves a signal and an impulse response."
    },
    "hsboscil": {
        "prefix": "hsboscil(kamp, ktone, kbrite, ibasfreq, iwfn, ioctfn [, ioctcnt] [, iphs])",
        "body": "hsboscil",
        "description": "An oscillator which takes tonality and brightness as arguments, relative to a base frequency."
    },
    "lpslot": {
        "prefix": "lpslot(islot)",
        "body": "lpslot",
        "description": "Selects the slot to be use by further lp opcodes."
    },
    "loscil": {
        "prefix": "loscil(xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] [, imod2] [, ibeg2] [, iend2])",
        "body": "loscil",
        "description": "Read sampled sound (mono or stereo) from a table."
    },
    "vdivv": {
        "prefix": "vdivv(ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose])",
        "body": "vdivv",
        "description": "Performs division between two vectorial control signals."
    },
    "phasor": {
        "prefix": "phasor({x, k}cps [, iphs])",
        "body": "phasor",
        "description": "Produce a normalized moving phase value."
    },
    "tablei": {
        "prefix": "tablei({a, i, k}ndx, ifn [, ixmode] [, ixoff] [, iwrap])",
        "body": "tablei",
        "description": "Accesses table values by direct indexing with linear interpolation."
    },
    "mp3len": {
        "prefix": "mp3len(ifilcod)",
        "body": "mp3len",
        "description": "Returns the length of an MP3 sound file."
    },
    "metro2": {
        "prefix": "metro2(freq, kswing [, iamp, initphase])",
        "body": "metro2",
        "description": "Trigger Metronome with Swing and Accents."
    },
    "hrtfearly": {
        "prefix": "hrtfearly(asrc, ksrcx, ksrcy, ksrcz, klstnrx, klstnry, klstnrz, ifilel, ifiler, idefroom [,ifade, isr, iorder, ithreed, kheadrot, iroomx, iroomy, iroomz, iwallhigh, iwalllow, iwallgain1, iwallgain2, iwallgain3, ifloorhigh, ifloorlow, ifloorgain1, ifloorgain2, ifloorgain3, iceilinghigh, iceilinglow, iceilinggain1, iceilinggain2, iceilinggain3])",
        "body": "hrtfearly",
        "description": "Generates 3D binaural audio with high-fidelity early reflections in a parametric room using a Phase Truncation algorithm."
    },
    "bformenc1": {
        "prefix": "bformenc1(asig, kalpha, kbeta)",
        "body": "bformenc1",
        "description": "Codes a signal into the ambisonic B format."
    },
    "getrow": {
        "prefix": "getrow(i/kin[], i/krow)",
        "body": "getrow",
        "description": "Gets a given row from a 2-dimensional array as a vector."
    },
    "foscili": {
        "prefix": "foscili(xamp, kcps, xcar, xmod, kndx [, ifn, iphs])",
        "body": "foscili",
        "description": "Basic frequency modulated oscillator with linear interpolation."
    },
    "/": {
        "prefix": "a / b  (no rate restriction)",
        "body": "/",
        "description": "Division operator."
    },
    "resonbnk": {
        "prefix": "resonbnk(ain, kPar[], kmin, kmax, iper [, imode, iscal, iskip])",
        "body": "resonbnk",
        "description": "A resonator filter bank."
    },
    "integ": {
        "prefix": "integ({a, k}sig [, iskip])",
        "body": "integ",
        "description": "Modify a signal by integration."
    },
    "exprandi": {
        "prefix": "exprandi(klambda, xamp, xcps)",
        "body": "exprandi",
        "description": "Exponential distribution random number generator with interpolation (positive values only)."
    },
    "vmult": {
        "prefix": "vmult(ifn, kval, kelements [, kdstoffset] [, kverbose])",
        "body": "vmult",
        "description": "Multiplies a vector in a table by a scalar value."
    },
    "maca": {
        "prefix": "maca(asig1 , asig2 [, asig3] [, asig4] [, asig5] [...])",
        "body": "maca",
        "description": "Multiply and accumulate a-rate signals only."
    },
    "pvsgain": {
        "prefix": "pvsgain(fsigin, kgain)",
        "body": "pvsgain",
        "description": "Scale the amplitude of a pv stream."
    },
    "transegr": {
        "prefix": "transegr(ia, idur, itype, ib [, idur2] [, itype] [, ic] ...)",
        "body": "transegr",
        "description": "Constructs a user-definable envelope with extended release segment."
    },
    "gtadsr": {
        "prefix": "gtadsr({a, k}sig, katt, kdec, ksus, krel, kgate)",
        "body": "gtadsr",
        "description": "A gated linear attack-decay-sustain with exponential release."
    },
    "fog": {
        "prefix": "fog(xamp, xdens, xtrans, aspd, koct, kband, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur [, iphs] [, itmode] [, iskip])",
        "body": "fog",
        "description": "Audio output is a succession of grains derived from data in a stored function table."
    },
    "outch": {
        "prefix": "outch(kchan1, asig1 [, kchan2] [, asig2] [...])",
        "body": "outch",
        "description": "Writes multi-channel audio data, with user-controllable channels, to an external device or stream."
    },
    "readf": {
        "prefix": "readf(ifilname)",
        "body": "readf",
        "description": "Read a line of text from an external file once each k-cycle."
    },
    "frac": {
        "prefix": "frac(x)",
        "body": "frac",
        "description": "Returns the fractional part of a decimal number."
    },
    "times": {
        "prefix": "times()",
        "body": "times",
        "description": "Read absolute time, in seconds, since the start of the performance."
    },
    "random": {
        "prefix": "random({i, k}min, kmax)",
        "body": "random",
        "description": "Generates a controlled pseudo-random number series between min and max values."
    },
    "ctrl21": {
        "prefix": "ctrl21(ichan, ictlno1, ictlno2, ictlno3, imin, imax [, ifn])",
        "body": "ctrl21",
        "description": "Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "display": {
        "prefix": "display(xsig, iprd [, inprds] [, iwtflg])",
        "body": "display",
        "description": "Displays the audio or control signals as an amplitude vs. time graph."
    },
    "skf": {
        "prefix": "skf(asig, xcf, x [, ihp, istor])",
        "body": "skf",
        "description": "Sallen-Key filter."
    },
    "trshift": {
        "prefix": "trshift(fin, kpshift [, kgain])",
        "body": "trshift",
        "description": "Streaming partial track frequency scaling."
    },
    "zarg": {
        "prefix": "zarg(kndx, kgain)",
        "body": "zarg",
        "description": "Reads from a location in za space at a-rate, adds some gain."
    },
    "lineto": {
        "prefix": "lineto(ksig, ktime)",
        "body": "lineto",
        "description": "Generate glissandos starting from a control signal."
    },
    "midinoteonpch": {
        "prefix": "midinoteonpch(xpch, xvelocity)",
        "body": "midinoteonpch",
        "description": "Gets a MIDI note number as a pitch-class value."
    },
    "harmon2": {
        "prefix": "harmon2(asig, koct, kfrq1, kfrq2, icpsmode, ilowes [, ipolarity])",
        "body": "harmon2",
        "description": "Analyze an audio input and generate harmonizing voices in synchrony with formants preserved."
    },
    "lufs": {
        "prefix": "lufs(kreset, ain1 [, ain2])",
        "body": "lufs",
        "description": "Momentary, Integrated and Short-Term Loudness meter in LUFS."
    },
    "switch": {
        "prefix": "switch expr",
        "body": "switch",
        "description": "Branches conditionally at initialization or during performance time."
    },
    "ctrlpreset": {
        "prefix": "ctrlpreset(ktag, kchnl, kctlno1, [kctlno2] [, kctlno3] ...)",
        "body": "ctrlpreset",
        "description": "Defines a preset for MIDI controllers."
    },
    "changed": {
        "prefix": "changed(kvar1 [, kvar2,..., kvarN])",
        "body": "changed",
        "description": "k-rate signal change detector."
    },
    "osciln": {
        "prefix": "osciln(kamp, ifrq, ifn, itimes)",
        "body": "osciln",
        "description": "Accesses table values at a user-defined frequency."
    },
    "dumpk": {
        "prefix": "dumpk(ksig, ifilname, iformat, iprd)",
        "body": "dumpk",
        "description": "Periodically writes an orchestra control-signal value to a named external file in a specific format."
    },
    "cpsmidib": {
        "prefix": "cpsmidib([irange])",
        "body": "cpsmidib",
        "description": "Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in cycles-per-second."
    },
    "zdf_2pole_mode": {
        "prefix": "zdf_2pole_mode(ain, xcf, Q [, istor])",
        "body": "zdf_2pole_mode",
        "description": "Zero-delay feedback implementation of 2 pole (12 dB/oct) filter with multimode output."
    },
    "cauchy": {
        "prefix": "cauchy(kalpha)",
        "body": "cauchy",
        "description": "Cauchy distribution random number generator."
    },
    "ziw": {
        "prefix": "ziw(isig, indx)",
        "body": "ziw",
        "description": "Writes to a zk variable at i-rate without mixing."
    },
    "prepiano": {
        "prefix": "prepiano(ifreq, iNS, iD, iK, iT30, iB, kbcl, kbcr, imass, ihvfreq, iinit, ipos, ivel, isfreq, issprea [, irattles, irubbers])",
        "body": "prepiano",
        "description": "Creates a tone similar to a piano string prepared in a Cageian fashion."
    },
    "grain": {
        "prefix": "grain(xamp, xpitch, xdens, kampoff, kpitchoff, kgdur, igfn, iwfn, imgdur [, igrnd])",
        "body": "grain",
        "description": "Generates granular synthesis textures."
    },
    "spat3dt": {
        "prefix": "spat3dt(ioutft, iX, iY, iZ, idist, ift, imode, irlen [, iftnocl])",
        "body": "spat3dt",
        "description": "Can be used to render an impulse response for a 3D space at i-time."
    },
    "pvsftw": {
        "prefix": "pvsftw(fsrc, ifna [, ifnf])",
        "body": "pvsftw",
        "description": "Writes amplitude and/or frequency data to function tables."
    },
    "outkpc": {
        "prefix": "outkpc(kchn, kprog, kmin, kmax)",
        "body": "outkpc",
        "description": "Sends MIDI program change messages at k-rate."
    },
    "ATSinterpread": {
        "prefix": "ATSinterpread(kfreq)",
        "body": "ATSinterpread",
        "description": "Allows a user to determine the frequency envelope of any [ATSbufread]."
    },
    "pitchamdf": {
        "prefix": "pitchamdf(asig, imincps, imaxcps [, icps] [, imedi] [, idowns] [, iexcps] [, irmsmedi])",
        "body": "pitchamdf",
        "description": "Follows the pitch of a signal based on the AMDF method (Average Magnitude Difference Function)."
    },
    "ceil": {
        "prefix": "ceil(x)",
        "body": "ceil",
        "description": "Returns the smallest integer not less than *x*."
    },
    "deinterleave": {
        "prefix": "deinterleave(kin[])",
        "body": "deinterleave",
        "description": "Deinterleaves arrays by picking alternate data from its input."
    },
    "turnoff3": {
        "prefix": "turnoff3(kinsno)",
        "body": "turnoff3",
        "description": "Turn off instance(s) of other instruments at performance time in the queue of scheduled events."
    },
    "vtablewi": {
        "prefix": "vtablewi(indx, ifn, ixmode, inarg1 [, inarg2, inarg3 , .... , inargN ])",
        "body": "vtablewi",
        "description": "Write vectors (to tables -or arrays of vectors) at init time."
    },
    "vtablei": {
        "prefix": "vtablei(indx, ifn, interp, ixmode, iout1 [, iout2, iout3, .... , ioutN ])",
        "body": "vtablei",
        "description": "Read vectors (from tables -or arrays of vectors)."
    },
    "midic14": {
        "prefix": "midic14(ictlno1, ictlno2, imin, imax [, ifn])",
        "body": "midic14",
        "description": "Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "vrandh": {
        "prefix": "vrandh(ifn,  krange, kcps, ielements [, idstoffset] [, iseed] [, isize] [, ioffset])",
        "body": "vrandh",
        "description": "Generates a vector of random numbers stored into a table, holding the values for a period of time."
    },
    "tigoto": {
        "prefix": "tigoto(label)",
        "body": "tigoto",
        "description": "Transfer control at i-time when a new note is being tied onto a previously held note."
    },
    "sfinstrm": {
        "prefix": "sfinstrm(ivel, inotenum, xamp, xfreq, instrnum, ifilhandle [, iflag] [, ioffset])",
        "body": "sfinstrm",
        "description": "Plays a SoundFont2 (SF2) sample instrument, generating a mono sound."
    },
    "fiopen": {
        "prefix": "fiopen(ifilename, imode)",
        "body": "fiopen",
        "description": "Opens a file in a specific mode."
    },
    "sndload": {
        "prefix": "sndload(Sfnam [, ifm [, ichn [, is [, iba [, iam [, istrt [, ilpmo [, ilps [, ilpe]]]]]]]]])",
        "body": "sndload",
        "description": "Loads a sound file into memory for use by [loscilx]."
    },
    "gaussi": {
        "prefix": "gaussi(krange, xamp, xcps)",
        "body": "gaussi",
        "description": "Gaussian distribution random number generator with controlled interpolation between values."
    },
    "lposcilsa2": {
        "prefix": "lposcilsa2(aamp, kfreqratio, kloop, kend, ift [,iphs])",
        "body": "lposcilsa2",
        "description": "Read stereo sampled sound from a table with looping and high precision."
    },
    "readfi": {
        "prefix": "readfi(ifilname)",
        "body": "readfi",
        "description": "Read a line of text from an external file once on initialisation."
    },
    "strchar": {
        "prefix": "strchar(Sstr [, ipos])",
        "body": "strchar",
        "description": "Return the ASCII code of the character in Sstr at ipos (defaults to zero which means the first character), or zero if ipos is out of range."
    },
    "trim": {
        "prefix": "trim({x, i}array, ilen)",
        "body": "trim",
        "description": "Adjust size of a one-dimensional array."
    },
    "trsplit": {
        "prefix": "trsplit(fin, ksplit [, kgainlow, kgainhigh])",
        "body": "trsplit",
        "description": "Streaming partial track frequency splitting."
    },
    "pluck": {
        "prefix": "pluck(kamp, kcps, icps, ifn, imeth [, iparm1] [, iparm2])",
        "body": "pluck",
        "description": "Produces a naturally decaying plucked string or drum sound."
    },
    "gbuzz": {
        "prefix": "gbuzz(xamp, xcps, knh, klh, kmul, ifn [, iphs])",
        "body": "gbuzz",
        "description": "Output is a set of harmonically related cosine partials."
    },
    "pvsbandr": {
        "prefix": "pvsbandr(fsigin, xlowcut, xlowfull, xhighfull, xhighcut [, ktype])",
        "body": "pvsbandr",
        "description": "A band reject filter working in the spectral domain."
    },
    "limit": {
        "prefix": "limit({a, i, k}sig, klow, khigh)",
        "body": "limit",
        "description": "Sets the lower and upper limits of the value it processes."
    },
    "readscratch": {
        "prefix": "readscratch([index])",
        "body": "readscratch",
        "description": "Returns one of four scalar values stored in the instance of an instrument."
    },
    "poscil": {
        "prefix": "poscil({a, k}amp, acps [, ifn, iphs])",
        "body": "poscil",
        "description": "High precision oscillator."
    },
    "rtclock": {
        "prefix": "rtclock()",
        "body": "rtclock",
        "description": "Read the real time clock from the operating system."
    },
    "outx": {
        "prefix": "outx(asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, asig9, asig10, asig11, asig12, asig13, asig14, asig15, asig16)",
        "body": "outx",
        "description": "Writes 16-channel audio data to an external device or stream."
    },
    "barmodel": {
        "prefix": "barmodel(kbcL, kbcR, iK, ib, kscan, iT30, ipos, ivel, iwid)",
        "body": "barmodel",
        "description": "Creates a tone similar to a struck metal bar."
    },
    "timek": {
        "prefix": "timek()",
        "body": "timek",
        "description": "Read absolute time, in k-rate cycles, since the start of the performance."
    },
    "sliderKawai": {
        "prefix": "sliderKawai(imin1, imax1, init1, ifn1, imin2, imax2, init2, ifn2, ..., imin16, imax16, init16, ifn16)",
        "body": "sliderKawai",
        "description": "Creates a bank of 16 different MIDI control message numbers from a KAWAI MM-16 midi mixer."
    },
    "streson": {
        "prefix": "streson(asig, kfr, kfdbgain)",
        "body": "streson",
        "description": "A string resonator with variable fundamental frequency."
    },
    "nchnls_hw": {
        "prefix": "nchnls_hw()",
        "body": "nchnls_hw",
        "description": "Returns the number of audio channels in the underlying hardware."
    },
    "butterbp": {
        "prefix": "butterbp(asig, xfreq, xband [, iskip])",
        "body": "butterbp",
        "description": "A band-pass Butterworth filter."
    },
    "endop": {
        "prefix": "endop",
        "body": "endop",
        "description": "Marks the end of an user-defined opcode block."
    },
    "trighold": {
        "prefix": "trighold({a, k}in, kdur)",
        "body": "trighold",
        "description": "Timed trigger, holds a value for a given time."
    },
    "deltap3": {
        "prefix": "deltap3(xdlt)",
        "body": "deltap3",
        "description": "Taps a delay line at variable offset times, uses cubic interpolation."
    },
    "fareylen": {
        "prefix": "fareylen(kfn)",
        "body": "fareylen",
        "description": "Returns the length of a Farey Sequence."
    },
    "ctrl14": {
        "prefix": "ctrl14(ichan, ictlno1, ictlno2, imin, imax [, ifn])",
        "body": "ctrl14",
        "description": "Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "fof": {
        "prefix": "fof(xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur [, iphs] [, ifmode] [, iskip])",
        "body": "fof",
        "description": "Produces sinusoid bursts useful for formant and granular synthesis."
    },
    "diskgrain": {
        "prefix": "diskgrain(Sfname, kamp, kfreq, kpitch, kgrsize, kprate, ifun, iolaps [,imaxgrsize , ioffset])",
        "body": "diskgrain",
        "description": "Synchronous granular synthesis, using a soundfile as source."
    },
    "timout": {
        "prefix": "timout(istrt, idur, label)",
        "body": "timout",
        "description": "Conditional branch during p-time depending on elapsed note time."
    },
    "event_i": {
        "prefix": "event_i(\"scorechar\", iinsnum, idelay, idur [, ip4] [, ip5] [, ...])",
        "body": "event_i",
        "description": "Generates a score event from an instrument."
    },
    "prealloc": {
        "prefix": "prealloc(insnum, icount)",
        "body": "prealloc",
        "description": "Creates space for instruments but does not run them."
    },
    "tone": {
        "prefix": "tone(asig, khp [, iskip])",
        "body": "tone",
        "description": "A first-order recursive low-pass filter with variable frequency response."
    },
    "ftloadk": {
        "prefix": "ftloadk(Sfilename, ktrig, iflag, ifn1 [, ifn2] [...])",
        "body": "ftloadk",
        "description": "Load a set of previously-allocated tables from a file."
    },
    "gendyc": {
        "prefix": "gendyc(kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, kampscl, kdurscl [, initcps] [, knum])",
        "body": "gendyc",
        "description": "Dynamic stochastic approach to waveform synthesis using cubic interpolation."
    },
    "seqtime": {
        "prefix": "seqtime(ktime_unit, kstart, kloop, kinitndx, kfn_times)",
        "body": "seqtime",
        "description": "Generates a trigger signal according to the values stored in a table."
    },
    "tambourine": {
        "prefix": "tambourine(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1] [, ifreq2])",
        "body": "tambourine",
        "description": "Semi-physical model of a tambourine sound."
    },
    "slider64table": {
        "prefix": "slider64table(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, ...., ictlnum64, imin64, imax64, init64, ifn64)",
        "body": "slider64table",
        "description": "Stores a bank of 64 different MIDI control messages to a table."
    },
    "midifiletempo": {
        "prefix": "midifiletempo({tempo: [, id:i], tempo: [, id:i]})",
        "body": "midifiletempo",
        "description": "Sets the playback tempo of a MIDI file. "
    },
    "bamboo": {
        "prefix": "bamboo(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1] [, ifreq2])",
        "body": "bamboo",
        "description": "Semi-physical model of a bamboo sound."
    },
    "slider16table": {
        "prefix": "slider16table(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, ...., ictlnum16, imin16, imax16, init16, ifn16)",
        "body": "slider16table",
        "description": "Stores a bank of 16 different MIDI control messages to a table."
    },
    "readscore": {
        "prefix": "readscore(Sin)",
        "body": "readscore",
        "description": "Read, preprocess and schedule a score from an input string."
    },
    "pareq": {
        "prefix": "pareq(asig, kc, kv, kq [, imode] [, iskip])",
        "body": "pareq",
        "description": "Implementation of Zoelzer&#x27;s parametric equalizer filters, with some modifications by the author."
    },
    "fmin": {
        "prefix": "fmin({i, k}arg1[], iarg2[])",
        "body": "fmin",
        "description": "Returns the minimum of its two arguments."
    },
    "ftmorf": {
        "prefix": "ftmorf(kftndx, iftfn, iresfn)",
        "body": "ftmorf",
        "description": "Uses an index into a table of ftable numbers to morph between adjacent tables in the list. This morphed function is written into the table referenced by _iresfn_ on every k-cycle."
    },
    "inletk": {
        "prefix": "inletk(Sname)",
        "body": "inletk",
        "description": "Receives a krate signal into an instrument from a named port."
    },
    "midicontrolchange": {
        "prefix": "midicontrolchange(xcontroller, xcontrollervalue [, ilow] [, ihigh])",
        "body": "midicontrolchange",
        "description": "Gets a MIDI control change value."
    },
    "midichannelaftertouch": {
        "prefix": "midichannelaftertouch(xchannelaftertouch [, ilow] [, ihigh])",
        "body": "midichannelaftertouch",
        "description": "Gets a MIDI channel&#x27;s aftertouch value."
    },
    "bformdec1": {
        "prefix": "bformdec1(isetup, abform[])",
        "body": "bformdec1",
        "description": "Decodes an ambisonic B format signal into loudspeaker specific signals."
    },
    "outkpb": {
        "prefix": "outkpb(kchn, kvalue, kmin, kmax)",
        "body": "outkpb",
        "description": "Sends MIDI pitch-bend messages at k-rate."
    },
    "vdelay3": {
        "prefix": "vdelay3(asig, adel, imaxdel [, iskip])",
        "body": "vdelay3",
        "description": "A variable time delay with cubic interpolation."
    },
    "vdelayxw": {
        "prefix": "vdelayxw(ain, adl, imd, iws [, ist])",
        "body": "vdelayxw",
        "description": "Variable delay opcodes with high quality interpolation."
    },
    "pvsmorph": {
        "prefix": "pvsmorph(fsig1, fsig2, kampint, kfrqint)",
        "body": "pvsmorph",
        "description": "Performs morphing (or interpolation) between two source fsigs."
    },
    "out": {
        "prefix": "out(asig [, asig2,....])",
        "body": "out",
        "description": "Writes audio data to an external device or stream, either from audio variables or from an audio array."
    },
    "filescal": {
        "prefix": "filescal(ktimescal, kamp, kpitch, Sfile, klock [,ifftsize, idecim, ithresh])",
        "body": "filescal",
        "description": "Phase-locked vocoder processing with onset detection/processing, &#x27;tempo-scaling&#x27;."
    },
    "slider8": {
        "prefix": "slider8(ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., ictlnum8, imin8, imax8, init8, ifn8)",
        "body": "slider8",
        "description": "Creates a bank of 8 different MIDI control message numbers."
    },
    "cell": {
        "prefix": "cell(ktrig, kreinit, ioutFunc, initStateFunc, iRuleFunc, ielements)",
        "body": "cell",
        "description": "Cellular Automaton."
    },
    "zkwm": {
        "prefix": "zkwm(ksig, kndx [, imix])",
        "body": "zkwm",
        "description": "Writes to a zk variable at k-rate with mixing."
    },
    "autocorr": {
        "prefix": "autocorr(kin[])",
        "body": "autocorr",
        "description": "This opcode takes in an input array and computes its autocorrelation."
    },
    "strindex": {
        "prefix": "strindex(S1, S2)",
        "body": "strindex",
        "description": "Return the position of the first occurence of S2 in S1, or -1 if not found. If S2 is empty, 0 is returned."
    },
    "maxabsaccum": {
        "prefix": "maxabsaccum(aAccumulator, aInput)",
        "body": "maxabsaccum",
        "description": "Accumulates the maximum of the absolute values of audio signals."
    },
    "turnoff2": {
        "prefix": "turnoff2({i, k}insno, kmode, krelease)",
        "body": "turnoff2",
        "description": "Turn off instance(s) of other instruments at performance time."
    },
    "diode_ladder": {
        "prefix": "diode_ladder(ain, xcf, xk [, inlp, isaturation, istor])",
        "body": "diode_ladder",
        "description": "Zero-delay feedback implementation of a 4 pole (24 dB/oct) diode low-pass filter."
    },
    "vco2": {
        "prefix": "vco2(kamp, kcps [, imode] [, kpw] [, kphs] [, inyx])",
        "body": "vco2",
        "description": "Implementation of a band-limited oscillator using pre-calculated tables."
    },
    "zkr": {
        "prefix": "zkr(kndx)",
        "body": "zkr",
        "description": "Reads from a location in zk space at k-rate."
    },
    "wgflute": {
        "prefix": "wgflute(kamp, kfreq, kjet, iatt, idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq] [, ijetrf] [, iendrf])",
        "body": "wgflute",
        "description": "Creates a tone similar to a flute."
    },
    "vrandi": {
        "prefix": "vrandi(ifn,  krange, kcps, ielements [, idstoffset] [, iseed] [, isize] [, ioffset])",
        "body": "vrandi",
        "description": "Generate a sort of &#x27;vectorial band-limited noise&#x27;."
    },
    "aftouch": {
        "prefix": "aftouch([imin] [, imax])",
        "body": "aftouch",
        "description": "Get the current after-touch value for this channel."
    },
    "splitrig": {
        "prefix": "splitrig(ktrig, kndx, imaxtics, ifn, kout1 [,kout2,...,koutN])",
        "body": "splitrig",
        "description": "Split a trigger signal (i.e. a timed sequence of control-rate impulses) into several channels following a structure designed by the user."
    },
    "midion": {
        "prefix": "midion(kchn, knum, kvel)",
        "body": "midion",
        "description": "Generates MIDI note messages at k-rate."
    },
    "tabmorphak": {
        "prefix": "tabmorphak(aindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 [, ifn3, ifn4, ... ifnN])",
        "body": "tabmorphak",
        "description": "Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables."
    },
    "ftlptim": {
        "prefix": "ftlptim(x)",
        "body": "ftlptim",
        "description": "Returns the loop segment start-time of a stored function table number."
    },
    "turnoff": {
        "prefix": "turnoff({i, k})",
        "body": "turnoff",
        "description": "Enables an instrument to turn itself off or to turn an instance of another instrument off."
    },
    "guiro": {
        "prefix": "guiro(kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1])",
        "body": "guiro",
        "description": "Semi-physical model of a guiro sound."
    },
    "midic21": {
        "prefix": "midic21(ictlno1, ictlno2, ictlno3, imin, imax [, ifn])",
        "body": "midic21",
        "description": "Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range."
    },
    "filebit": {
        "prefix": "filebit(ifilcod [, iallowraw])",
        "body": "filebit",
        "description": "Returns the number of bits in each sample in a sound file."
    },
    "poisson": {
        "prefix": "poisson(klambda)",
        "body": "poisson",
        "description": "Poisson distribution random number generator (positive values only)."
    },
    "envlpxr": {
        "prefix": "envlpxr({x, k}amp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind])",
        "body": "envlpxr",
        "description": "The _envlpx_ opcode with a final release segment."
    },
    "zdf_1pole": {
        "prefix": "zdf_1pole(ain, xcf [, kmode, istor])",
        "body": "zdf_1pole",
        "description": "Zero-delay feedback implementation of a 1 pole (6 dB/oct) filter."
    },
    "tvconv": {
        "prefix": "tvconv(asig1, asig2, xfreez1, xfreez2, iparts, ifils)",
        "body": "tvconv",
        "description": "A time-varying convolution (FIR filter) opcode."
    },
    "vbapg": {
        "prefix": "vbapg(kazim [,kelev] [, kspread] [, ilayout])",
        "body": "vbapg",
        "description": "Calculates the gains for a sound location for up to 64."
    },
    "clockoff": {
        "prefix": "clockoff(inum)",
        "body": "clockoff",
        "description": "Stops one of a number of internal clocks."
    },
    "atonek": {
        "prefix": "atonek(ksig, khp [, iskip])",
        "body": "atonek",
        "description": "A hi-pass filter whose transfer functions are the complements of the [tonek] opcode."
    },
    "poscil3": {
        "prefix": "poscil3({a, k}amp, acps [, ifn, iphs])",
        "body": "poscil3",
        "description": "High precision oscillator with cubic interpolation."
    },
    "cauchyi": {
        "prefix": "cauchyi(klambda, xamp, xcps)",
        "body": "cauchyi",
        "description": "Cauchy distribution random number generator with interpolation between values."
    },
    "diskin": {
        "prefix": "diskin(ifilco [, kpitc [, iskiptim [, iwraparoun [, iforma [, iskipinit]]]]])",
        "body": "diskin",
        "description": "Reads audio data from an external device or stream and can alter its pitch."
    },
    "loop_le": {
        "prefix": "loop_le({i, k}ndx, incr, imax, label)",
        "body": "loop_le",
        "description": "Construction of looping operations."
    },
    "pvstencil": {
        "prefix": "pvstencil(fsigin, kgain, klevel, iftable)",
        "body": "pvstencil",
        "description": "Transforms a pvoc stream according to a masking function table."
    },
    "mute": {
        "prefix": "mute(insnum [, iswitch])",
        "body": "mute",
        "description": "Mutes/unmutes new instances of a given instrument."
    },
    "MixerGetLevel": {
        "prefix": "MixerGetLevel(isend, ibuss)",
        "body": "MixerGetLevel",
        "description": "Gets the level at which signals from the send are being added to the buss."
    },
    "chnget": {
        "prefix": "chnget(Sname)",
        "body": "chnget",
        "description": "Reads data from a channel of the inward named software bus."
    },
    "vdelayx": {
        "prefix": "vdelayx(ain, adl, imd, iws [, ist])",
        "body": "vdelayx",
        "description": "A variable delay opcode with high quality interpolation."
    },
    "centroid": {
        "prefix": "centroid(asig, ktrig, ifftsize)",
        "body": "centroid",
        "description": "Calculate the spectral centroid of an audio signal on a given trigger."
    },
    "remove": {
        "prefix": "remove(insnum)",
        "body": "remove",
        "description": "Removes the definition of an instrument as long as it is not in use."
    },
    "slider8tablef": {
        "prefix": "slider8tablef(ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, ...., ictlnum8, imin8, imax8, init8, ifn8, icutoff8)",
        "body": "slider8tablef",
        "description": "Stores a bank of 8 different MIDI control messages to a table, filtered before output."
    },
    "resonxk": {
        "prefix": "resonxk(ksig, kcf, kb [, inumlayer, iscl, istor])",
        "body": "resonxk",
        "description": "Control signal resonant filter stack."
    },
    "massign": {
        "prefix": "massign(ichnl, insnu [, ireset])",
        "body": "massign",
        "description": "Assigns a MIDI channel number to a Csound instrument."
    },
    "mclock": {
        "prefix": "mclock(ifreq)",
        "body": "mclock",
        "description": "Sends a MIDI CLOCK message."
    },
    "chano": {
        "prefix": "chano({a, k}val, kchan)",
        "body": "chano",
        "description": "Send data to a channel of the outward software bus."
    },
    "alwayson": {
        "prefix": "alwayson(Tinstrument [, p4, ..., pn])",
        "body": "alwayson",
        "description": "Activates the indicated instrument in the orchestra header, without need for an i statement."
    },
    "nstrnum": {
        "prefix": "nstrnum(\"name\")",
        "body": "nstrnum",
        "description": "Returns the number of a named instrument."
    },
    "pchbend": {
        "prefix": "pchbend([imin] [, imax])",
        "body": "pchbend",
        "description": "Get the current pitch-bend value for this channel."
    },
    "pvadd": {
        "prefix": "pvadd(ktimpnt, kfmod, ifilcod, ifn, ibins [, ibinoffset] [, ibinincr] [, iextractmode] [, ifreqlim] [, igatefn])",
        "body": "pvadd",
        "description": "Reads from a _pvoc_ file and uses the data to perform additive synthesis."
    },
    "tablefilter": {
        "prefix": "tablefilter(kouttable, kintatble, kmode, kparam)",
        "body": "tablefilter",
        "description": "Filters a source table and writes result into a destination table."
    },
    "vtabk": {
        "prefix": "vtabk(kndx, ifn, kout1 [, kout2, kout3, .... , koutN ])",
        "body": "vtabk",
        "description": "Read vectors (from tables -or arrays of vectors) at k-rate."
    },
    "timedseq": {
        "prefix": "timedseq(ktimpnt, ifn, kp1 [,kp2, kp3, ...,kpN])",
        "body": "timedseq",
        "description": "Time Variant Sequencer."
    },
    "wterrain": {
        "prefix": "wterrain(kamp, kpch, k_xcenter, k_ycenter, k_xradius, k_yradius, itabx, itaby)",
        "body": "wterrain",
        "description": "A simple wave-terrain synthesis opcode."
    },
    "gauss": {
        "prefix": "gauss({i, k}range)",
        "body": "gauss",
        "description": "Gaussian distribution random number generator."
    },
    "marimba": {
        "prefix": "marimba(kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec [, idoubles] [, itriples])",
        "body": "marimba",
        "description": "Physical model related to the striking of a wooden block as found in a marimba."
    },
    "pvbufread": {
        "prefix": "pvbufread(ktimpnt, ifile)",
        "body": "pvbufread",
        "description": "Reads from a phase vocoder analysis file and makes the retrieved data available."
    },
    "cent": {
        "prefix": "cent(x)",
        "body": "cent",
        "description": "Calculates a factor to raise/lower a frequency by a given amount of cents."
    },
    "ftsamplebank": {
        "prefix": "ftsamplebank(SDirectory, kFirstTableNumber, kTrigger, kSkipTime, kFormat, kChannel)",
        "body": "ftsamplebank",
        "description": "Reads a directory for sound files and loads them to a series of GEN01 function tables."
    },
    "olabuffer": {
        "prefix": "olabuffer(kin, ioverlap)",
        "body": "olabuffer",
        "description": "Sum overlapping frames of audio as k-rate arrays and read as an audio signal."
    },
    "vdelayxs": {
        "prefix": "vdelayxs(ain1, ain2, adl, imd, iws [, ist])",
        "body": "vdelayxs",
        "description": "A stereo variable delay opcode with high quality interpolation."
    },
    "vpow": {
        "prefix": "vpow(ifn, kval, kelements [, kdstoffset] [, kverbose])",
        "body": "vpow",
        "description": "Raises each element of a vector to a scalar power."
    },
    "tabplay": {
        "prefix": "tabplay(ktrig, knumtics, kfn, kout1 [,kout2,..., koutN])",
        "body": "tabplay",
        "description": "Plays-back control-rate signals on trigger-temporization basis."
    },
    "slider32": {
        "prefix": "slider32(ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., ictlnum32, imin32, imax32, init32, ifn32)",
        "body": "slider32",
        "description": "Creates a bank of 32 different MIDI control message numbers."
    },
    "pvsftr": {
        "prefix": "pvsftr(fsrc, ifna [, ifnf])",
        "body": "pvsftr",
        "description": "Reads amplitude and/or frequency data from function tables."
    },
    "+": {
        "prefix": "+a  (no rate restriction)",
        "body": "+",
        "description": "Addition operator."
    },
    "flashtxt": {
        "prefix": "flashtxt(which, String)",
        "body": "flashtxt",
        "description": "Allows text to be displayed from instruments like sliders etc. (only on Unix and Windows at present)"
    },
    "wguide2": {
        "prefix": "wguide2(asig, xfreq1, xfreq2, kcutoff1, kcutoff2, kfeedback1, kfeedback2)",
        "body": "wguide2",
        "description": "A model of beaten plate consisting of two parallel delay-lines and two first-order lowpass filters."
    },
    "lpshold": {
        "prefix": "lpshold(kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...])",
        "body": "lpshold",
        "description": "Generate control signal consisting of held segments."
    },
    "pvsdemix": {
        "prefix": "pvsdemix(fleft, fright, kpos, kwidth, ipoints)",
        "body": "pvsdemix",
        "description": "Spectral azimuth-based de-mixing of stereo sources, with a reverse-panning result."
    },
    "oscil": {
        "prefix": "oscil({x, k}amp, xcps [, ifn, iphs])",
        "body": "oscil",
        "description": "A simple oscillator without any interpolation."
    },
    "syncloop": {
        "prefix": "syncloop(kamp, kfreq, kpitch, kgrsize, kprate, klstart, klend, ifun1, ifun2, iolaps[,istart, iskip])",
        "body": "syncloop",
        "description": "Synchronous granular synthesis."
    },
    "schedwhen": {
        "prefix": "schedwhen(ktrigger, kinsnum, kwhen, kdur [, ip4] [, ip5] [...])",
        "body": "schedwhen",
        "description": "Adds a new score event."
    },
    "inrg": {
        "prefix": "inrg(kstart, ain1 [,ain2, ain3, ..., ainN])",
        "body": "inrg",
        "description": "Reads audio from a range of adjacent audio channels from the audio input device."
    },
    "resyn": {
        "prefix": "resyn(fin, kscal, kpitch, kmaxtracks, ifn)",
        "body": "resyn",
        "description": "Streaming partial track additive synthesis with cubic phase interpolation."
    },
    "vbap4": {
        "prefix": "vbap4(asig, kazim [, kelev] [, kspread])",
        "body": "vbap4",
        "description": "Distributes an audio signal among 4 channels."
    },
    "zir": {
        "prefix": "zir(indx)",
        "body": "zir",
        "description": "Reads from a location in zk space at i-rate."
    },
    "deltapx": {
        "prefix": "deltapx(adel, iwsize)",
        "body": "deltapx",
        "description": "Read from or write to a delay line with interpolation."
    },
    "portk": {
        "prefix": "portk(ksig, khtim [, isig])",
        "body": "portk",
        "description": "Applies portamento to a step-valued control signal."
    },
    "tan": {
        "prefix": "tan(x)",
        "body": "tan",
        "description": "Returns the tangent of _x_ (_x_ in radians)."
    },
    "spat3di": {
        "prefix": "spat3di(ain, iX, iY, iZ, idist, ift, imode [, istor])",
        "body": "spat3di",
        "description": "Positions the input sound in a 3D space with the sound source position set at i-time."
    },
    "dust": {
        "prefix": "dust(kamp, kdensity)",
        "body": "dust",
        "description": "Generates random impulses from 0 to 1."
    },
    "vbapgmove": {
        "prefix": "vbapgmove(idur, ispread, ifldnum, ifld1 [, ifld2] [...])",
        "body": "vbapgmove",
        "description": "Calculates the gains for a sound location between multiple channels with moving virtual sources."
    },
    "i": {
        "prefix": "i(x)",
        "body": "i",
        "description": "Returns an init-type equivalent of a k-rate argument or array element or directly returns an i-rate argument."
    },
    "control": {
        "prefix": "control(knum)",
        "body": "control",
        "description": "Configurable slider controls for realtime user input. Requires Winsound or TCL/TK. It reads a slider&#x27;s value."
    },
    "specscal": {
        "prefix": "specscal(wsigin, ifscale, ifthresh)",
        "body": "specscal",
        "description": "Scales an input spectral datablock with spectral envelopes."
    },
    "setrow": {
        "prefix": "setrow(i/kin[], i/krow)",
        "body": "setrow",
        "description": "Sets a given row of a 2-dimensional array from a vector."
    },
    "scoreline": {
        "prefix": "scoreline(Sin, ktrig)",
        "body": "scoreline",
        "description": "Issues one or more score line events from an instrument."
    },
    "slider16": {
        "prefix": "slider16(ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., ictlnum16, imin16, imax16, init16, ifn16)",
        "body": "slider16",
        "description": "Creates a bank of 16 different MIDI control message numbers."
    },
    "biquada": {
        "prefix": "biquada(asig, ab0, ab1, ab2, aa0, aa1, aa2 [, iskip])",
        "body": "biquada",
        "description": "A sweepable general purpose biquadratic digital filter with a-rate parameters."
    },
    "wterrain2": {
        "prefix": "wterrain2(kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, kcurve, kcurveparam)",
        "body": "wterrain2",
        "description": "A wave-terrain synthesis opcode using different curves."
    },
    "reson": {
        "prefix": "reson(asig, xcf, xbw [, iscl] [, iskip])",
        "body": "reson",
        "description": "A second-order resonant filter."
    },
    "cos": {
        "prefix": "cos(x)",
        "body": "cos",
        "description": "Returns the cosine of _x_ (_x_ in radians)."
    },
    "tablexkt": {
        "prefix": "tablexkt(xndx, kfn, kwarp, iwsize [, ixmode] [, ixoff] [, iwrap])",
        "body": "tablexkt",
        "description": "Reads function tables with linear, cubic, or sinc interpolation."
    },
    "oscils": {
        "prefix": "oscils(iamp, icps, iphs [, iflg])",
        "body": "oscils",
        "description": "A simple, fast sine oscillator."
    },
    "line": {
        "prefix": "line(ia, idur, ib)",
        "body": "line",
        "description": "Trace a straight line between specified points."
    },
    "strsubk": {
        "prefix": "strsubk(Ssrc, kstart, kend)",
        "body": "strsubk",
        "description": "Extract a substring of the source string."
    },
    "syncphasor": {
        "prefix": "syncphasor(xcps, asyncin [, iphs])",
        "body": "syncphasor",
        "description": "Produces a normalized moving phase value with sync input and output."
    },
    "convolve": {
        "prefix": "convolve(ain, ifilcod [, ichannel])",
        "body": "convolve",
        "description": "Convolves a signal and an impulse response."
    },
    "tabrec": {
        "prefix": "tabrec(ktrig_start, ktrig_stop, knumtics, kfn, kin1 [,kin2,...,kinN])",
        "body": "tabrec",
        "description": "Records control-rate signals on trigger-temporization basis."
    },
    "cmplxprod": {
        "prefix": "cmplxprod(kin1[], kin2[])",
        "body": "cmplxprod",
        "description": "Complex  product of two arrays of the same size and in real-imaginary interleaved format."
    },
    "rnd31": {
        "prefix": "rnd31({i, k}scl, krpow [, iseed])",
        "body": "rnd31",
        "description": "31-bit bipolar random opcodes with controllable distribution."
    },
    "chnexport": {
        "prefix": "chnexport(Sname, imod [, itype, idflt, imin, imax])",
        "body": "chnexport",
        "description": "Export a global variable as a channel of the bus."
    },
    "chn": {
        "prefix": "chn(Sname, imod [, itype, idflt, imin, ima, ix, iy, iwidth, iheight, Sattributes])",
        "body": "chn",
        "description": "Declare a channel of the named software bus."
    },
    "soundin": {
        "prefix": "soundin(ifilcod [, iskptim] [, iformat] [, iskipinit] [, ibufsize])",
        "body": "soundin",
        "description": "Reads audio data from an external device or stream."
    },
    "lpinterp": {
        "prefix": "lpinterp(islot1, islot2, kmix)",
        "body": "lpinterp",
        "description": "Computes a new set of poles from the interpolation between two analysis."
    },
    "octcps": {
        "prefix": "octcps(cps)",
        "body": "octcps",
        "description": "Converts a cycles-per-second value to octave-point-decimal."
    },
    "pvsbandwidth": {
        "prefix": "pvsbandwidth(fsig)",
        "body": "pvsbandwidth",
        "description": "Calculate the spectral bandwidth of a signal from its discrete Fourier transform."
    },
    "combinv": {
        "prefix": "combinv(asig, krvt, ilpt [, iskip] [, insmps])",
        "body": "combinv",
        "description": "Reverberates an input signal with a &amp;#8220;colored&amp;#8221; frequency response. with a FIR filter."
    },
    "otafilter": {
        "prefix": "otafilter(in:a, cf:{a, k}, res:{a, k}, drive: [, stor:i])",
        "body": "otafilter",
        "description": "Resonant 4pole non-linear lowpass filter."
    },
    "ntom": {
        "prefix": "ntom(Snote)",
        "body": "ntom",
        "description": "Convert note name to midi note number."
    },
    "sprintfk": {
        "prefix": "sprintfk(Sfmt, xarg [, xarg [, ... ]])",
        "body": "sprintfk",
        "description": "printf-style formatted output to a string variable at k-rate."
    },
    "crossfm": {
        "prefix": "crossfm(xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2])",
        "body": "crossfm",
        "description": "Two oscillators, mutually frequency and/or phase modulated by each other."
    },
    "scanhammer": {
        "prefix": "scanhammer(isrc, idst, ipos, imult)",
        "body": "scanhammer",
        "description": "Copies from one table to another with a gain control."
    },
    "comb": {
        "prefix": "comb(asig, krvt, ilpt [, iskip] [, insmps])",
        "body": "comb",
        "description": "Reverberates an input signal with a &amp;#8220;colored&amp;#8221; frequency response."
    },
    "moscil": {
        "prefix": "moscil(kchn, knum, kvel, kdur, kpause)",
        "body": "moscil",
        "description": "Sends a stream of the MIDI notes."
    },
    "tableimix": {
        "prefix": "tableimix(idft, idoff, ilen, is1ft, is1off, is1g, is2ft, is2off, is2g)",
        "body": "tableimix",
        "description": "Mixes two tables."
    },
    "instr_block": {
        "prefix": "instr block",
        "body": [
            "instr ${1:name/number}",
            "endin"
        ],
        "description": "Instrument block"
    },
    "opcode_block": {
        "prefix": "opcode name, outtypes, intypes",
        "body": [
            "opcode ${1:name}, ${2:outtypes}, ${2:intypes}",
            "endop"
        ],
        "description": "Legacy User Defined Opcode"
    },
    "opcode_modern_block": {
        "prefix": "opcode name(var:intypes, ...):(outtypes)",
        "body": [
            "opcode ${1:name}(${2:var:intypes)}:(${3:outtypes})",
            "endop"
        ],
        "description": "Modern User Defined Opcode"
    },
    "while_block": {
        "prefix": "while",
        "body": [
            "while ${1:condition} do",
            "od"
        ],
        "description": "While loop"
    },
    "for_block": {
        "prefix": "for",
        "body": [
            "for ${1:var} in ${2:array-like} do",
            "od"
        ],
        "description": "for loop"
    },
    "until_block": {
        "prefix": "until",
        "body": [
            "until ${1:condition} do",
            "od"
        ],
        "description": "until loop"
    },
    "switch_block": {
        "prefix": "switch",
        "body": [
            "switch ${1:condition}",
            "endsw"
        ],
        "description": "Switch block"
    },
    "if_block": {
        "prefix": "if",
        "body": [
            "if ${1:condition} then",
            "endif"
        ],
        "description": "If statement"
    },
    "CsoundSynthesizer": {
        "prefix": "CsoundSynthesizer (.csd structure)",
        "body": [
            "<CsoundSynthesizer>",
            "<CsOptions>",
            "</CsOptions>",
            "<CsInstruments>",
            "",
            "sr = 44100",
            "ksmps = 1",
            "nchnls = 2",
            "0dbfs = 1",
            "",
            "",
            "",
            "",
            "",
            "",
            "</CsInstruments>",
            "<CsScore>",
            "",
            "",
            "",
            "</CsScore>",
            "</CsoundSynthesizer>"
        ],
        "description": "CsoundSynthesizer tag"
    }
}
